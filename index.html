<!--
    Aug 2019
    3.9.5 beta 2023
    @nimadez

    # Voxel Builder
    # Voxel-based 3D modeling application

    [ Code Map ]
    01. Initialize
    02. Scene
    03. Camera
    04. HDRI and Skybox
    05. Pipeline (post-process)
    06. Material
    07. Builder (SPS particles)
    08. Palette (color palette)
    09. Helper (overlays)
    10. Tool, ToolBakery
    11. Symmetry
    12. Voxelizer
    13. Generator
    14. Bakery
    15. Storage
    16. Memory
    17. Project
    18. UserInterface
    19. UserInterfaceAdvanced
    20. Preferences
    21. Events
    22. Utils
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="Voxel-based 3D modeling application for desktop and mobile browsers">
    <meta name="author" content="@nimadez">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@nimadez">
    <meta name="twitter:creator" content="@nimadez">
    <meta name="twitter:title" content="Voxel Builder">
    <meta name="twitter:description" content="Voxel-based 3D modeling application for desktop and mobile browsers">
    <meta name="twitter:image" content="https://repository-images.githubusercontent.com/565157149/a9fc7534-727b-4b8c-8f5d-03fa42091f0b">
    <title>Voxel Builder</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAiJJREFUWEdjZBhgwDjA9jMMTgfkNm38zsjAwIEROv8Z2ifV+1cRCrW8po3/samZVOeP4WEMAVyaYQYyMjL6Tqz124LLEYT0ozsCpwPqpCIx7Gh6thwshs0nIPG8po0ZDAwM09NE2hgk2C6j6MelF9MBjRvWMDAyBheKlzLwMj8hyhCYIpjvSXE81kSIy6CXv7UZZr6uYfjPwFA7uc6/BT2IcOnDF3IkOQBkIS7Dchs3RjMyMiyJFZrIoMhxguiQw+qAjJbN0mz//j3R4rjCECLUSpRh5AQ/yGCc5QAuA3/942XoeDGLgYHh/9pJdQEhhOKfUMIl2QHYoiG/ZaPd/38MB4ME5jDocO0lKsTg2RpfoUJsoiI3+PFGATRfg0s0XNnqP8P/h5PrAhSIdSg2z+KtC4jxGcM/Zl0Gpr+XPfhWMpjxbCAp+AmGAL5QgCUumI3oofTxjzzDxFcdDP///185uT4gAldUE6wNiQoFLNFEKPUTlQiJSQcgNbY82xkc+RaRHPxERQEx0YAe/Cvf1jPc/KnB8O0Hg8ScNv+X+HIawSggJhTQHUBs8JMQAps2MTD89y0WL2TgZn6B4qFtH3IYvASmkBX8RDuAUCgg206K74eWA3KaNyky/f9/T4/zAkOAYCfOdEWzECAmGki1nKQoGBQOIOQImocAsgNwJQJcLWay6wJsGnG1/f/9YlSa0uJ3H1/Jhy5HVElIioGkqh11AACQYjUw+9rFtwAAAABJRU5ErkJggg==">
    <script src="https://nimadez.github.io/voxel-builder/libs/babylon.js"></script>
    <script src="https://nimadez.github.io/voxel-builder/libs/babylonjs.materials.min.js"></script>
    <script src="https://nimadez.github.io/voxel-builder/libs/babylonjs.loaders.min.js"></script>
    <script src="https://nimadez.github.io/voxel-builder/libs/babylonjs.serializers.min.js"></script>
    <script src="https://nimadez.github.io/voxel-builder/libs/babylon.gui.min.js"></script>
    <style>
        @font-face {
            font-family: 'DroidSans';
            src: url(data:font/truetype;charset=utf-8;base64,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FSERIQEhESMGVv0I/iXLugKPA8n9wwIW/eoCPft1AZNsAcX+OwW2pP48ov34AcYCqAAAAP//AH3+FASYBcsSJgAmAAARBwB6AfwAAAALtgFPKiQYICUBKzUAAAD//wDHAAADvgdzEiYAKAAAEQcAQ/+3AVIAFbQBDAUmAbj/wrQSDAEAJQErNQArNQD//wDHAAADvgdzEiYAKAAAEQcAdgA/AVIAE0ALARgFJgFKDBIBACUBKzUAKzUAAAD//wDHAAADvgdzEiYAKAAAEQcAw//xAVIAFbQBDAUmAbj//bQUDAEAJQErNQArNQD//wDHAAADvgcrEiYAKAAAEQcAav/1AVIAF0ANAgEVBSYCAQEMIAEAJQErNTUAKzU1AAAA//8APgAAAmQHcxImACwAABEHAEP+tQFSABW0AQwFJgG4/6i0EgwBACUBKzUAKzUA//8AUgAAAooHcxImACwAABEHAHb/eAFSABNACwEYBSYBagwSAQAlASs1ACs1AAAA//8AEQAAAqkHcxImACwAABEHAMP/DwFSABNACwEMBSYBAhQMAQAlASs1ACs1AAAA//8AQAAAAncHKxImACwAABEHAGr/DQFSABdADQIBFQUmAgEADCABACUBKzU1ACs1NQAAAAACAC8AAAT8BbYAEAAfAF1AOhoaDhFbCGchICEBGBxaDhAQAQ5kIBsQXxgPAAEPAD8AbwCvAN8A/wAGCABAGh1IAAACHGAOEhdgAgMAP+E/4RE5LyteXXEz4TIBEOYyMi8Q4TJdEPbhETkvMTATMxEhMh4BEhUUAgYEIyERIyU0LgIrAREhFSERMyAAL5gBl5n4rl9gtv73qP6SmAQIQn64dckBUP6wogEIAQwDJQKRXLX+9LC5/um7XgKDYJLVikP+DqL+HQEk//8AxwAABQ4HNRImADEAABEHAMUAiwFSABNACwEgBSYBCiEvCgAlASs1ACs1AAAA//8Aff/sBXEHcxImADIAABEHAEMAVAFSABW0AigFJgK4/6u0LigKACUBKzUAKzUA//8Aff/sBXEHcxImADIAABEHAHYBAgFSABNACwI0BSYCWCguCgAlASs1ACs1AAAA//8Aff/sBXEHcxImADIAABEHAMMArgFSABNACwIoBSYCBTAoCgAlASs1ACs1AAAA//8Aff/sBXEHNRImADIAABEHAMUAfQFS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b3B5cmlnaHQgqSAyMDA3LCBHb29nbGUgQ29ycG9yYXRpb24uAABEAHIAbwBpAGQAIABTAGEAbgBzAABEcm9pZCBTYW5zAABSAGUAZwB1AGwAYQByAABSZWd1bGFyAABBAHMAYwBlAG4AZABlAHIAIAAtACAARAByAG8AaQBkACAAUwBhAG4AcwAAQXNjZW5kZXIgLSBEcm9pZCBTYW5zAABEAHIAbwBpAGQAIABTAGEAbgBzAABEcm9pZCBTYW5zAABWAGUAcgBzAGkAbwBuACAAMQAuADAAMAAgAGIAdQBpAGwAZAAgADEAMQAzAABWZXJzaW9uIDEuMDAgYnVpbGQgMTEzAABEAHIAbwBpAGQAUwBhAG4AcwAARHJvaWRTYW5zAABEAHIAbwBpAGQAIABpAHMAIABhACAAdAByAGEAZABlAG0AYQByAGsAIABvAGYAIABHAG8AbwBnAGwAZQAgAGEAbgBkACAAbQBhAHkAIABiAGUAIAByAGUAZwBpAHMAdABlAHIAZQBkACAAaQBuACAAYwBlAHIAdABhAGkAbgAgAGoAdQByAGkAcwBkAGkAYwB0AGkAbwBuAHMALgAARHJvaWQgaXMgYSB0cmFkZW1hcmsgb2YgR29vZ2xlIGFuZCBtYXkgYmUgcmVnaXN0ZXJlZCBpbiBjZXJ0YWluIGp1cmlzZGljdGlvbnMuAABBAHMAYwBlAG4AZABlAHIAIABDAG8AcgBwAG8AcgBhAHQAaQBvAG4AAEFzY2VuZGVyIENvcnBvcmF0aW9uAABEAHIAbwBpAGQAIABTAGEAbgBzACAAaQBzACAAYQAgAGgAdQBtAGEAbgBpAHMAdAAgAHMAYQBuAHMAIABzAGUAcgBpAGYAIAB0AHkAcABlAGYAYQBjAGUAIABkAGUAcwBpAGcAbgBlAGQAIABmAG8AcgAgAHUAcwBlAHIAIABpAG4AdABlAHIAZgBhAGMAZQBzACAAYQBuAGQAIABlAGwAZQBjAHQAcgBvAG4AaQBjACAAYwBvAG0AbQB1AG4AaQBjAGEAdABpAG8AbgAuAABEcm9pZCBTYW5zIGlzIGEgaHVtYW5pc3Qgc2FucyBzZXJpZiB0eXBlZmFjZSBkZXNpZ25lZCBmb3IgdXNlciBpbnRlcmZhY2VzIGFuZCBlbGVjdHJvbmljIGNvbW11bmljYXRpb24uAABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBzAGMAZQBuAGQAZQByAGMAbwByAHAALgBjAG8AbQAvAABodHRwOi8vd3d3LmFzY2VuZGVyY29ycC5jb20vAABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBzAGMAZQBuAGQAZQByAGMAbwByAHAALgBjAG8AbQAvAHQAeQBwAGUAZABlAHMAaQBnAG4AZQByAHMALgBoAHQAbQBsAABodHRwOi8vd3d3LmFzY2VuZGVyY29ycC5jb20vdHlwZWRlc2lnbmVycy5odG1sAABMAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAEEAcABhAGMAaABlACAATABpAGMAZQBuAHMAZQAsACAAVgBlAHIAcwBpAG8AbgAgADIALgAwAABMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wAABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBwAGEAYwBoAGUALgBvAHIAZwAvAGwAaQBjAGUAbgBzAGUAcwAvAEwASQBDAEUATgBTAEUALQAyAC4AMAAAaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wAABEAHIAbwBpAGQAIABTAGEAbgBzAABEcm9pZCBTYW5zAAAAAgAAAAAAAP9mAGYAAAAAAAAAAAAAAAAAAAAAAAAAAADTAAAAAQACAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQCsAKMAhACFAL0AlgDoAIYAjgCLAJ0AqQCkAQIAigEDAIMAkwDyAPMAjQCXAIgAwwDeAPEAngCqAPUA9AD2AKIArQDJAMcArgBiAGMAkABkAMsAZQDIAMoAzwDMAM0AzgDpAGYA0wDQANEArwBnAPAAkQDWANQA1QBoAOsA7QCJAGoAaQBrAG0AbABuAKAAbwBxAHAAcgBzAHUAdAB2AHcA6gB4AHoAeQB7AH0AfAC4AKEAfwB+AIAAgQDsAO4AugDXANgA3QDZALIAswC2ALcAxAC0ALUAxQCHAL4AvwC8AQQHdW5pMDBBRAlvdmVyc2NvcmUMZm91cnN1cGVyaW9yAAAAAAIABQAC//8AAwAAAAEAAAAAx/6w3wAAAADBmjMAAAAAAMgXT/YAAQAAAA4AAAAYAAAAAAACAAEAAADSAAEABAAAAAIAAAABAAAACgAeACwAAWxhdG4ACAAEAAAAAP//AAEAAAABa2VybgAIAAAAAQAAAAEABAACAAgAAQAIAAER7gAEAAAAZgDWANYBiAGOAeQBjgHqAlACagK0Aw4DaAOmA+QESgSkBOYFQAVGBnAGmgeUCI4JEANoAYgKIgoiCigKIgo6CmAKdgp8CiIKIgqOCpgKKArKCuAK4Ar2CygLPgGIC2AL/gv+C2AMlA0qAmoNyA4SDcgNyANoA2gDaANoDlQOcg5yDnIOcg5yBEoO4A7gDuAO4A8uCiIKIgoiCiIKIgoiCo4KKBB4EHgQeBB4EIIQkBCQEJAQkBCQCo4QphCmEKYQphCwESoB5AHkEUgRSAAsACT/rgAsACkANwBSADkAUgA6AGYAOwApADwAUgA9ACkARv/DAEf/wwBI/8MASv/XAFL/wwBU/8MAVwApAFkAKQBaABQAXAApAIL/rgCD/64AhP+uAIX/rgCG/64Ah/+uAIj/XACOACkAjwApAJAAKQCRACkAnwBSAKj/wwCp/8MAqv/DAKv/wwCs/8MArf/DALT/wwC1/8MAtv/DALf/wwC4/8MAuv/DAL8AKQDBACkAAQAtAHsAFQAm/8MAKv/DADL/wwA0/8MAN/+aADj/1wA5/5oAOv+uADz/mgCJ/8MAlP/DAJX/wwCW/8MAl//DAJj/wwCa/8MAm//XAJz/1wCd/9cAnv/XAJ//mgABADf/mgAZAAX/rgAK/64AJv/sACr/7AAy/+wANP/sADf/hQA4/+wAOf/DADr/1wA8/5oAif/sAJT/7ACV/+wAlv/sAJf/7ACY/+wAmv/sAJv/7ACc/+wAnf/sAJ7/7ACf/5oAyf+uAMz/rgAGACz/7AA3/+wAOf/sADv/7AA8/+wAn//sABIABQApAAoAKQAMACkAJv/XACr/1wAy/9cANP/XAEAAKQBgACkAif/XAJT/1wCV/9cAlv/XAJf/1wCY/9cAmv/XAMkAKQDMACkAFgAP/8MAEf/DACT/7AAs/+wAN//DADn/7AA6/+wAO//sADz/1wA9/+wAgv/sAIP/7ACE/+wAhf/sAIb/7ACH/+wAiP/DAI7/7ACP/+wAkP/sAJH/7ACf/9cAFgAFAD0ACgA9AAwAKQAP/5oAEf+aACIAKQAk/9cAOQAUADoAFAA8ABQAQAApAGAAKQCC/9cAg//XAIT/1wCF/9cAhv/XAIf/1wCI/8MAnwAUAMkAPQDMAD0ADwAFACkACgApACb/7AAq/+wAMv/sADT/7ACJ/+wAlP/sAJX/7ACW/+wAl//sAJj/7ACa/+wAyQApAMwAKQAPAAUAKQAKACkAJv/XACr/1wAy/9cANP/XAIn/1wCU/9cAlf/XAJb/1wCX/9cAmP/XAJr/1wDJACkAzAApABkABf+aAAr/mgAm/+wAKv/sADL/7AA0/+wAN/+FADj/7AA5/64AOv/DADz/mgCJ/+wAlP/sAJX/7ACW/+wAl//sAJj/7ACa/+wAm//sAJz/7ACd/+wAnv/sAJ//mgDJ/5oAzP+aABYAD//DABH/wwAk/+wALP/sADf/wwA5/9cAOv/sADv/1wA8/9cAPf/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/1wCO/+wAj//sAJD/7ACR/+wAn//XABAAD/8zABH/MwAk/64AJv/sADv/7AA8/+wAPf/XAIL/rgCD/64AhP+uAIX/rgCG/64Ah/+uAIj/cQCJ/+wAn//sABYAD//DABH/wwAk/+wALP/sADf/wwA5/9cAOv/sADv/1wA8/9cAPf/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/wwCO/+wAj//sAJD/7ACR/+wAn//XAAEAN//sAEoABQBSAAoAUgAP/5oAEP+aABH/mgAiACkAJP+FACb/wwAq/8MAMv/DADT/wwA2/+wANwAUAET/hQBG/4UAR/+FAEj/hQBK/5oAUP+uAFH/rgBS/4UAU/+uAFT/hQBV/64AVv+FAFj/rgBZ/8MAWv/DAFv/wwBc/8MAXf/DAIL/hQCD/4UAhP+FAIX/hQCG/4UAh/+FAIj/cQCJ/8MAlP/DAJX/wwCW/8MAl//DAJj/wwCa/8MAov+FAKP/hQCk/4UApf+FAKb/hQCn/4UAqP+FAKn/hQCq/4UAq/+FAKz/hQCt/4UAs/+uALT/hQC1/4UAtv+FALf/hQC4/4UAuv+FALv/rgC8/64Avf+uAL7/rgC//8MAwf/DAMb/rgDH/5oAyQBSAMwAUgAKAA//1wAR/9cAJP/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/1wA+AAUAUgAKAFIAD/+aABH/mgAiACkAJP/DACb/1wAq/9cAMv/XADT/1wBE/8MARv/DAEf/wwBI/8MASv/DAFD/1wBR/9cAUv/DAFP/1wBU/8MAVf/XAFb/1wBY/9cAgv/DAIP/wwCE/8MAhf/DAIb/wwCH/8MAiP+FAIn/1wCU/9cAlf/XAJb/1wCX/9cAmP/XAJr/1wCi/8MAo//DAKT/wwCl/8MApv/DAKf/wwCo/8MAqf/DAKr/wwCr/8MArP/DAK3/wwCz/9cAtP/DALX/wwC2/8MAt//DALj/wwC6/8MAu//XALz/1wC9/9cAvv/XAMkAUgDMAFIAPgAFAGYACgBmAA//rgAR/64AJP/XACb/7AAq/+wAMv/sADT/7ABE/9cARv/XAEf/1wBI/9cASv/sAFD/7ABR/+wAUv/XAFP/7ABU/9cAVf/sAFb/1wBY/+wAXf/sAIL/1wCD/9cAhP/XAIX/1wCG/9cAh//XAIj/rgCJ/+wAlP/sAJX/7ACW/+wAl//sAJj/7ACa/+wAov/XAKP/1wCk/9cApf/XAKb/1wCn/9cAqP/XAKn/1wCq/9cAq//XAKz/1wCt/9cAs//sALT/1wC1/9cAtv/XALf/1wC4/9cAuv/XALv/7AC8/+wAvf/sAL7/7ADJAGYAzABmACAABQApAAoAKQAm/9cAKv/XADL/1wA0/9cARv/sAEf/7ABI/+wAUv/sAFT/7ACJ/9cAlP/XAJX/1wCW/9cAl//XAJj/1wCa/9cAqP/sAKn/7ACq/+wAq//sAKz/7ACt/+wAtP/sALX/7AC2/+wAt//sALj/7AC6/+wAyQApAMwAKQBEAAUAUgAKAFIAD/+aABH/mgAiACkAJP+aACb/1wAq/9cAMv/XADT/1wA2/+wARP+aAEb/mgBH/5oASP+aAEr/mgBQ/8MAUf/DAFL/mgBT/8MAVP+aAFX/wwBW/64AWP/DAFv/1wBc/+wAXf/DAIL/mgCD/5oAhP+aAIX/mgCG/5oAh/+aAIj/cQCJ/9cAlP/XAJX/1wCW/9cAl//XAJj/1wCa/9cAov+aAKP/mgCk/5oApf+aAKb/mgCn/5oAqP+aAKn/mgCq/5oAq/+aAKz/mgCt/5oAs//DALT/mgC1/5oAtv+aALf/mgC4/5oAuv+aALv/wwC8/8MAvf/DAL7/wwC//+wAwf/sAMkAUgDMAFIAAQAK/9cABAAFAD0ACgA9AMkAPQDMAD0ACQAFAGYACgBmAFkAFABaABQAXAAUAL8AFADBABQAyQBmAMwAZgAFAAUAKQAKACkASgAUAMkAKQDMACkAAQAK/8MABAAFACkACgApAMkAKQDMACkAAgBb/9cAXf/sAAwABQBmAAoAZgBE/+wASv/sAKL/7ACj/+wApP/sAKX/7ACm/+wAp//sAMkAZgDMAGYABQAFAFIACgBSAFcAFADJAFIAzABSAAUABQBSAAoAUgBJABQAyQBSAMwAUgAMAAUAKQAKACkAUv/XAKj/1wC0/9cAtf/XALb/1wC3/9cAuP/XALr/1wDJACkAzAApAAUABQA9AAoAPQBJABQAyQA9AMwAPQAIAFL/7ACo/+wAtP/sALX/7AC2/+wAt//sALj/7AC6/+wAJwAF/64ACv+uAA3/hQAPAEQAHgBEACL/wwAm/+wAKv/sAC0AXgAy/+wANP/sADf/hQA4/+wAOf/DADr/1wA8/5oAPQA7AEn/7ABX/+wAWf/XAFr/7ABc/9cAgv/XAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//1wDB/9cAyf+uAMz/rgAlAAX/rgAK/64ADf+FAA8ARAAeAEQAIv/DACb/7AAq/+wAMv/sADT/7AA3/4UAOP/sADn/wwA6/9cAPP+aAD0AOwBJ/+wAV//sAFn/1wBa/+wAXP/XAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//1wDB/9cAyf+uAMz/rgAlAAX/rgAK/64ADf9/AA8ARAAeAEQAIv/XACb/7AAq/+wALQBeADL/7AA0/+wAN/+FADj/7AA5/8MAOv/XADz/mgA9ADsAV//lAFn/1QBa/+UAXP/bAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//2wDB/9sAyf+uAMz/rgAnAAX/ZgAK/2YADf9/AA8ARAAeAEQAIv/XACb/7AAq/+wALQBeADL/7AA0/+wAN/+FADj/7AA5/8MAOv/XADz/mgA9ADsAV//lAFn/1QBa/+UAXP/bAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//2wDB/9sAyP9mAMn/rgDL/2YAzP+uABIABQApAAoAKQAQ/9cAJv/sADL/7AA0/+wAhP/sAIn/7ACK/+wAj//sAJT/7ACV/+wAlv/sAJf/7ACY/+wAmv/sAMkAKQDMACkAEAAFACkACgApABD/1wAm/+wAMv/sADT/7ACJ/+wAi//sAJT/7ACV/+wAlv/sAJf/7ACY/+wAmv/sAMkAKQDMACkABwAk/+wAgv/sAIP/7ACE/+wAhf/sAIb/7ACH/+wAGwAM/9cAD//DABH/wwAk/+wALP/sAC3/9gA2/+wAN//DADn/1wA6/+wAO//XADz/1wA9/+wAQP/XAGD/1wCC/+wAg//sAIT/7ACF/+wAhv/sAIf/7ACI/9cAjv/sAI//7ACQ/+wAkf/sAJ//1wATAA//1wAR/9cAJP/sADD/7AA9/+wARP/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/1wCi/+wAo//sAKT/7ACl/+wApv/sAKf/7ABSAAUAUgAJ/8MACgBSAAwAPQANACkAD/+aABD/mgAR/5oAIgApACT/mgAm/9cAKv/XAC3/vgAw/8MAMv/XADT/1wA2/+wANwAnADkAKQA6ABQAQAA9AET/mgBG/5oAR/+aAEj/mgBJ/+UASv+aAFD/wwBR/8MAUv+aAFP/wwBU/5oAVf/DAFb/rgBY/8MAWf/XAFr/7ABb/9cAXP/sAF3/wwBgAD0Agv+aAIP/mgCE/5oAhf+aAIb/mgCH/5oAiP9xAIn/1wCU/9cAlf/XAJb/1wCX/9cAmP/XAJr/1wCi/5oAo/+aAKT/mgCl/5oApv+aAKf/mgCo/5oAqf+aAKr/mgCr/5oArP+aAK3/mgCz/8MAtP+aALX/mgC2/5oAt/+aALj/mgC6/5oAu//DALz/wwC9/8MAvv/DAL//7ADB/+wAyQBSAMwAUgACAAX/mAAK/9cAAwAF/5gACv/XAMz/1wAFAAX/bwAK/28ASf/bAFv/1wBd/+wAAgAF/74ACv++AB4ABQA9AAoAPQAP/74AEf++ACL/tABG//YAR//2AEj/9gBJABQASv/2AFL/9gBU//YAVwAGAKj/9gCp//YAqv/2AKv/9gCs//YArf/2ALT/9gC1//YAtv/2ALf/9gC4//YAuv/2AMkAPQDK/40AzAA9AM3/jQDQAAwABwAFAD0ACgA9AA//vgAR/74ASQAUAMkAPQDMAD0AKQAk/64ALAApADcAUgA5AFIAOgBmADsAKQA8AFIAPQApAEb/wwBH/8MASP/DAEr/1wBS/8MAVP/DAFcAKQBZACkAWgAUAIL/rgCD/64AhP+uAIX/rgCG/64Ah/+uAIj/XACOACkAjwApAJAAKQCRACkAnwBSAKj/wwCp/8MAqv/DAKv/wwCs/8MArf/DALT/wwC1/8MAtv/DALf/wwC4/8MAuv/DAAIAGQAFAAUAAAAKAAsAAQAPABEAAwAkACcABgApACkACgAsACwACwAuAC8ADAAyADUADgA3AD4AEgBEAEYAGgBIAEsAHQBOAE4AIQBQAFIAIgBVAFcAJQBZAF4AKACCAIcALgCJAJIANACUAJgAPgCaAJ8AQwCiAK0ASQCzALgAVQC6AL8AWwDBAMEAYQDGAMgAYgDLAMsAZQABAAAACgAcAB4AAWxhdG4ACAAEAAAAAP//AAAAAAAA)
                format('truetype');
        }
        @font-face {
            font-family: 'Material Icons'; font-style: normal; font-weight: 400;
            src: url(https://nimadez.github.io/voxel-builder/assets/materialicons.woff2)
                format('woff2');
        }
        :root { /* orange, steelblue */
            --btn-color: #9aaabd;
            --btn-bg: #303947;
            --input-bg: #222833;
            --input-color: #96a2b8;
            --label: #727c8f;
            --cat-bg: #252833;
            --cat-color: #5e6777;
        }
        * { margin: 0; padding: 0; outline: none; }
        html, body { overscroll-behavior-y: contain; user-select: none; overflow: hidden; touch-action: pan-x; -webkit-tap-highlight-color: transparent; } /* prevent pull-down refresh and text selection on chrome mobile + prevent forced scroll + blue tap highlight on touch */
        body { background: white; font-family: 'DroidSans'; font-size: 11px; color: silver; position: fixed; width: 100%; height: 100%; cursor: default; }
        a { font-size: 11px; color: #6a8cad; text-decoration: none; }
        a:hover { color: orange; text-decoration: none; }
        input[type=number] { width: 50px; height: 10px; text-indent: 2px; margin: 0 0 2px 0; background: var(--input-bg); color: var(--input-color); padding: 3px; font-size: 11px; border: solid 1px #343c49; border-radius: 2px; text-align: left; }
        input[type=number]:hover { color: steelblue; border: solid 1px #43495a; }
        input[type=text] { width: 90px; background: var(--input-bg); color: var(--input-color); padding: 3px; font-size: 11px; text-indent: 1px; border: solid 1px #343c49; border-radius: 2px; text-align: left; }
        input[type=text]:hover { color: steelblue; border: solid 1px #43495a; cursor: text; }
        input[type=range] { accent-color: steelblue; width: 100%; height: 2px; margin: 0 0 8px 0; }
        input[type=range]::-webkit-slider-thumb { transform: scale(0.7); }
        input[type=range]::-webkit-slider-thumb:hover { cursor: pointer; }
        input[type=checkbox] { accent-color: steelblue; transform: scale(0.8); margin: 3px 0 3px 0; vertical-align: -2px; }
        input[type=checkbox]:disabled { opacity: 0.5; }
        input[type=color] { width: 28px; height: 28px; border-radius: 3px; background: none; outline: none; border: none; }
        input[type=color]::-webkit-color-swatch-wrapper { padding: 0; border: solid 1px #00000000; }
        input[type=color]::-webkit-color-swatch { border: none; border-radius: 3px; border: solid 1px #444; }
        input[type=color]:hover { background: orange; cursor: pointer; }
        ul { position: absolute; list-style-type: none; }
        ul li { background: var(--btn-bg); color: var(--btn-color); border: 1px solid #161a2096; border-radius: 3px; padding: 2px; text-align: center; }
        ul li:hover, .tool_selector, .tool_bakery_selector { background: orange; color: black; }
        button { background: var(--btn-bg); color: var(--btn-color); box-shadow: inset 1px 1px 1px #37414e, inset -1px -1px 1px #2f3742; border-radius: 3px; padding: 5px 0 5px 0; border: 1px solid #161a2080; }
        button:hover { background: orange; color: #222; cursor: pointer; }
        button:disabled { background: var(--btn-bg); opacity: 0.5; pointer-events: none; }
        label { color: var(--label); margin: 0; font-size: 11px; }
        select { width: 100%; background: var(--btn-bg); color: var(--btn-color); font-size: 11px; padding: 4px 0 4px 0; border: solid 1px #161a2080; border-radius: 3px; outline: none; text-align: center; vertical-align: middle; }
        select:hover { color: steelblue; cursor: pointer; }
        option { color: silver; background: var(--btn-bg); }
        iframe { border: none; }
        #canvas_render { z-index: 0; position: absolute; width: 100%; height: 100%; background: linear-gradient(0deg, #333946 0%, #545c70 100%); }
        #canvas_palette { z-index: 1; position: relative; width: 100%; height: 64000px; }
        .menu_R { z-index: 1000; background: #2a2f3a; position: absolute; top: 0; right: 0; padding: 0 6px 6px 6px; width: 100px; height: fit-content; transform: translate(200px, 0); transition: transform 0.15s ease; box-shadow: -1px 1px 3px #404b58AA; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; }
        .menu_R li { background: none; text-align: left; border: none; padding: 0; cursor: default; }
        .menu_R li:hover { background: none; }
        .menu_R button { width: 100%; font-size: 11px; border-radius: 2px; }
        .menu_R .category { color: var(--cat-color); background: var(--cat-bg); font-size: 10px; letter-spacing: 0.06em; text-align: center; margin: 3px 0 3px 0; padding: 2px 0 2px 0; border-radius: 0; }
        .menu_R .category:hover { color: var(--cat-color); background: var(--cat-bg); cursor: default; }
        .menu_R :first-child { cursor: pointer; }
        .menu_R :first-child span { color: var(--btn-color); letter-spacing: 0.06em; font-size: 10px; vertical-align: -4px; }
        .menu_R li i:first-child { color: var(--label); margin-top: 6px; }
        .menu_R li:hover i:first-child { color: orange; }
        .menu_L { z-index: 1000; background: #2a2f3a; position: absolute; top: 0; left: 0; padding: 0 6px 6px 6px; width: 100px; height: fit-content; transform: translate(-200px, 0); transition: transform 0.15s ease; box-shadow: 1px 1px 3px #404b58AA; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; }
        .menu_L li { background: none; text-align: left; border: none; padding: 0; cursor: default; }
        .menu_L li:hover { background: none; }
        .menu_L button { width: 100%; font-size: 11px; border-radius: 2px; }
        .menu_L .category { color: var(--cat-color); background: var(--cat-bg); font-size: 10px; letter-spacing: 0.06em; text-align: center; margin: 3px 0 3px 0; padding: 2px 0 2px 0; border-radius: 0; }
        .menu_L .category:hover { color: var(--cat-color); background: var(--cat-bg); cursor: default; }
        .menu_L :first-child { cursor: pointer; }
        .menu_L :first-child span { color: var(--btn-color); letter-spacing: 0.06em; font-size: 10px; vertical-align: -4px; }
        .menu_L li i:first-child { color: var(--label); margin-top: 6px; transform: rotate(180deg); }
        .menu_L li:hover i:first-child { color: orange; }
        #toolbar_C { z-index: 500; width: 200px; left: 50%; margin-left: -100px; top: 3px; text-align: center; }
        #toolbar_C li { display: inline-block; color: var(--btn-color); width: 65px; letter-spacing: 0.06em; font-size: 10px; padding: 5px 0 5px 0; margin: 0 -2px 0 -2px; box-shadow: inset 1px 1px 1px #37414e, inset -1px -1px 1px #2f3742; border-radius: 0; cursor: pointer; }
        #toolbar_C li:hover { color: black; }
        #toolbar_C li:nth-child(1) { border-top-left-radius: 3px; border-bottom-left-radius: 3px; }
        #toolbar_C li:nth-child(3) { border-top-right-radius: 3px; border-bottom-right-radius: 3px; }
        #toolbar_C li.mode_select { background: var(--btn-bg); color: orange; }
        #toolbar_C_mem { z-index: 500; width: 200px; left: 50%; margin-left: -100px; top: 28px; text-align: center; }
        #toolbar_C_mem li { display: inline-block; width: 47px; font-size: 10px; color: var(--btn-color); padding: 5px 0 5px 0; margin: 0 -2px 0 -2px; box-shadow: inset 1px 1px 1px #37414e, inset -1px -1px 1px #2f3742; border-radius: 0; cursor: pointer; }
        #toolbar_C_mem li:hover { color: #222; }
        #toolbar_C_mem :nth-child(1) { font-weight: normal; border-top-left-radius: 3px; border-bottom-left-radius: 3px; }
        #toolbar_C_mem :nth-child(2) { font-weight: normal; border-top-right-radius: 3px; border-bottom-right-radius: 3px; }
        #toolbar_C_mem :nth-child(3) { margin-left: 4px; font-weight: normal; border-top-left-radius: 3px; border-bottom-left-radius: 3px; }
        #toolbar_C_mem :nth-child(4) { font-weight: normal; border-right: 1px solid #161a2096; border-top-right-radius: 3px; border-bottom-right-radius: 3px; }
        #toolbar_R { z-index: 500; width: 60px; position: absolute; right: 0; top: 0; }
        #toolbar_R li { display: inline; background: none; border: none; padding: 0; }
        #toolbar_R li:nth-child(1) button { padding-top: 4px; padding-bottom: 4px; }
        #toolbar_R button { width: 100%; font-size: 9px; padding: 6px 5px 6px 5px; border-radius: 0; }
        #toolbar_R li:first-child :first-child { width: 50%; float: left; }
        #toolbar_R li:first-child :last-child { width: 50%; }
        #toolbar_L { z-index: 500; width: 60px; position: absolute; left: 0; top: 0; }
        #toolbar_L li { display: inline; background: none; border: none; padding: 0; }
        #toolbar_L li:nth-child(1) button { padding-top: 4px; padding-bottom: 4px; }
        #toolbar_L button { width: 100%; font-size: 9px; padding: 6px 5px 6px 5px; border-radius: 0; }
        #toolbar_L li:first-child :first-child { width: 50%; float: left; }
        #toolbar_L li:first-child :last-child { width: 50%; }
        #hover { z-index: 600; top: 25%; left: 25%; position: absolute; background: none; }
        #hover li { padding: 3px; box-shadow: inset 1px 1px 1px #37414e, inset -1px -1px 1px #2f3742; cursor: pointer; }
        #hover li:nth-child(1) { padding: 5px; margin: -2px; cursor: move; box-shadow: none; }
        #hover li:nth-child(2) { position: absolute; top: -125%; left: 0%; }
        #hover li:nth-child(3) { position: absolute; top: 0%; left: 125%; }
        #hover li:nth-child(4) { position: absolute; top: 0%; left: -125%; }
        #hover li:nth-child(5) { position: absolute; top: 115%; left: -115%; }
        #hover li:nth-child(6) { position: absolute; top: 115%; left: 115%; }
        #hover li:nth-child(7) { position: absolute; top: -115%; left: -115%; }
        #hover li:nth-child(8) { position: absolute; top: -115%; left: 115%; }
        #hover li:nth-child(9) { position: absolute; top: 125%; left: 0%; }
        #palette { z-index: 500; width: 41px; background: #31394b20; position: absolute; left: 3px; top: 80px; bottom: 135px; overflow-y: scroll; overflow-x: hidden; }
        #colorpicker { z-index: 500; position: absolute; width: 28px; left: 6px; bottom: 95px; }
        #marquee { z-index: 500; display: none; background: #00ffff20; border: dotted 2px aqua; position: absolute; }
        #menu-about .about { font-size: 11px; line-height: 1.3em; background: #21262e; color: #98a1ac; padding: 5px 5px 0 5px; cursor: help; }
        #menu-about .about h1 { font-size: 12px; font-weight: normal; color: #98a1ac; letter-spacing: 1px; cursor: help; }
        #menu-texture li.img { display: inline-block; }
        #menu-texture li :hover { border-color: orange; }
        #menu-texture li.pattern { display: inline-block; }
        #menu-texture li.pattern button { width: 48px; }
        #menu-texture img { object-fit: fill; border: solid 1px #6b798d; width: 24px; height: 24px; margin: 0 5px 4px 2px; }
        #btn-symm-axis { color: orange; font-size: 12px; font-weight: bold; }
        #btn-symm-axis:hover { background: var(--input-bg); }
        #btn-helper-symmetry { z-index: 500; display: unset; font-size: 18px; font-weight: bold; text-shadow: 0 0 2px black; width: 20px; padding: 5px; position: absolute; right: 3px; bottom: 90px; text-align: center; cursor: pointer; }
        #btn-helper-workplane { z-index: 500; display: unset; width: 20px; padding: 5px; position: absolute; right: 3px; bottom: 120px; text-align: center; cursor: pointer; }
        #btn-helper-workplane i { font-size: 18px; color: aqua; opacity: 0.6; }
        #input-env-background { width: 100%; height: 18px; }
        #input-env-lightcolor { width: 100%; height: 18px; }
        #input-material-emissive { width: 100%; height: 18px; }
        #reticle { z-index: 500; display: none; width: 100px; height: 100px; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; text-align: center; pointer-events: none; }
        #reticle :nth-child(1) { font-size: 12px; color: #00ffff60; line-height: 100px; grid-column: 1; grid-row: 1; }
        #reticle :nth-child(2) { border: solid 1px #cccccc10; margin: 25px; grid-column: 1; grid-row: 1; }
        #reticle :nth-child(3) { border: dashed 1px #cccccc20; border-radius: 50%; transform: scale(1.2); grid-column: 1; grid-row: 1; }
        #axisview-hitbox { z-index: 500; display: none; width: 40px; height: 40px; position: absolute; right: 30px; bottom: 30px; }
        #appiframe { z-index: 6000; display: none; position: absolute; left: 50%; top: 50%; }
        #info { z-index: 10; mix-blend-mode: screen; color: #97a5b880; font-size: 9px; position: absolute; width: 300px; bottom: 2px; left: 50%; margin-left: -150px; text-align: center; pointer-events: none; }
        #info span { z-index: 10; color: #97a5b8; letter-spacing: 0.05em; }
        #confirm { z-index: 2500; display: none; background: #2a2f3aDD; width: 200px; position: absolute; left: 50%; top: 50%; margin-left: -110px; margin-top: -30px; padding: 8px; border-radius: 3px; text-transform: uppercase; box-shadow: 0 0 3px #000000AA; text-align: center; }
        #confirm span { width: 100%; margin-bottom: 5px; font-size: 11px; color: orange; display: block; }
        #confirm button { width: 48%; font-size: 11px; text-transform: uppercase; }
        #confirmblocker { z-index: 2400; display: none; opacity: 0.8; background: #181b22; position: absolute; width: 100%; height: 100%; }
        #notifier { z-index: 2000; display: none; background: #2a2f3aF1; color: #ff8989; border: solid 1px #222; box-shadow: 0 0 3px #21262e99; font-size: 11px; font-weight: bold; position: absolute; width: fit-content; left: 50%; top: 50%; margin-left: -200px; margin-top: -20px; padding: 4px 6px 4px 6px; letter-spacing: 1px; text-align: center; border-radius: 3px; pointer-events: none; }
        #help { z-index: 5000; font-size: 12px; background: #181c22; border: solid 1px #2c333d; padding: 8px; position: absolute; width: 80%; height: 90%; left: 50%; bottom: -100%; margin-left: -42%; transition: 0.5s; overflow-y: scroll; overflow-x: hidden; border-radius: 5px; border-bottom-left-radius: 0; border-bottom-right-radius: 0; cursor: help; }
        #help h1 { font-size: 12px; color: orange; letter-spacing: 1px; display: inline; overflow: hidden; }
        #help b { color: #6a8cad; font-weight: bold; font-style: normal; }
        #help i { color: #8c9fb3; font-style: normal; }
        #help img { border-radius: 3px; }
        #loadingscreen { z-index: 5000; opacity: 0.9; transition: opacity 1s ease-out; background: #181b22; position: absolute; width: 100%; height: 100%; }
        #loadingscreen .progress { color: slategray; font-size: 10px; letter-spacing: 0.2em; width: 200px; height: 20px; position: absolute; left: 50%; top: 50%; margin-left: -100px; margin-top: 40px; text-align: center; }
        #loadingscreen .logo { transform-style: preserve-3d; animation: bouncing 2s infinite; width: 30px; height: 30px; position: absolute; left: 50%; top: 50%; margin-left: -15px; margin-top: -30px; }
        #intro { z-index: 6000; opacity: 0; color: #97a5b8; font-size: 10px; line-height: 1.5em; letter-spacing: 0.1em; transition: opacity 0.5s; position: absolute; width: 200px; left: 50%; margin-left: -100px; bottom: 100px; text-transform: uppercase; text-align: center; pointer-events: none; }
        #intro b { font-weight: bold; }
        .dropzone { padding: 2px; background: #22263090; color: #586474; border: dotted 1px #14171b; border-radius: 3px; font-size: 10px; text-align: center; }
        .dropzone:hover { background: #222630; color: #586474; }
        .flag { color: tomato; font-size: 9px; }
        .spacer { height: 3px; }
        .material-icons { font-family: 'Material Icons'; font-weight: normal; font-style: normal; font-size: 16px; vertical-align: middle; text-align: center; line-height: 1; letter-spacing: normal; text-transform: none; display: inline-block; white-space: nowrap; word-wrap: normal; direction: ltr; pointer-events: none; font-feature-settings: 'liga'; -webkit-font-feature-settings: 'liga'; -webkit-font-smoothing: antialiased; }
        ::-webkit-scrollbar { width: 7px; }
        ::-webkit-scrollbar-track { background: none; }
        ::-webkit-scrollbar-thumb { background: steelblue; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: orange; }    
        /* source: https://www.rareprogrammer.com/bouncing-cube-css-loader */
        .cube { transform-style: preserve-3d; transform: rotateX(45deg) rotateZ(45deg); animation: rotation 2s infinite; }
        .cube-faces { transform-style: preserve-3d; height: 30px; width: 30px; position: relative; transform-origin: 0 0; transform: translateX(0) translateY(0) translateZ(-30px); }
        .cube-face { position: absolute; inset: 0; background: #ffa50020; border: solid 1px orange; }
        .cube-face.top { transform: translateZ(30px); }
        .cube-face.front { transform-origin: 0 50%; transform: rotateY(-90deg); }
        .cube-face.back { transform-origin: 0 50%; transform: rotateY(-90deg) translateZ(-30px); }
        .cube-face.right { transform-origin: 50% 0; transform: rotateX(-90deg) translateY(-30px); }
        .cube-face.left { transform-origin: 50% 0; transform: rotateX(-90deg) translateY(-30px) translateZ(30px); }
        @keyframes rotation {
            0% { transform: rotateX(45deg) rotateY(0) rotateZ(45deg); animation-timing-function: cubic-bezier(0.17, 0.84, 0.44, 1); }
            50% { transform: rotateX(45deg) rotateY(0) rotateZ(225deg); animation-timing-function: cubic-bezier(0.76, 0.05, 0.86, 0.06); }
            100% { transform: rotateX(45deg) rotateY(0) rotateZ(405deg); animation-timing-function: cubic-bezier(0.17, 0.84, 0.44, 1); }
        }
        @keyframes bouncing {
            0% { transform: translateY(-10px); animation-timing-function: cubic-bezier(0.76, 0.05, 0.86, 0.06); }
            45% { transform: translateY(10px); animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1); }
            100% { transform: translateY(-10px); animation-timing-function: cubic-bezier(0.76, 0.05, 0.86, 0.06); }
        }
    </style>
</head>
<body>
    <canvas id="canvas_render" ondrop="dropHandler(event)" ondragover="dragHandler(event)" ondragleave="dragLeaveHandler(event)"></canvas>
    <ul id="toolbar_R">
        <li>
            <button title="Preferences" onclick="ui.toggleMenuPrefs()"><i class="material-icons">settings</i></button>
            <button title="About" onclick="ui.toggleMenuAbout()"><i class="material-icons" style="color:steelblue">help</i></button>
        </li>
        <li title="File"><button onclick="ui.toggleMenuFile()">FILE</button></li>
        <li title="Generator"><button onclick="ui.toggleMenuGenerator()">CREATE</button></li>
        <li title="Voxelizer"><button onclick="ui.toggleMenuVoxelizer()">VOXELIZE</button></li>
        <li title="Symmetry"><button onclick="ui.toggleMenuSymmetry()">SYMM</button></li>
        <li title="Model"><button onclick="ui.toggleMenuModel()">MODEL</button></li>
        <li title="Paint"><button onclick="ui.toggleMenuPaint()">PAINT</button></li>
        <li title="Voxels"><button onclick="ui.toggleMenuVoxels()">VOXELS</button></li>
        <li title="Bakery"><button onclick="ui.toggleMenuBakery()">BAKERY</button></li>
        <li title="Bakes"><button onclick="ui.toggleMenuBakes()">BAKES</button></li>
    </ul>
    <ul id="toolbar_L">
        <li>
            <button title="Pixel Monk" onclick="ui.openAppIframe('pixel-monk')"><i class="material-icons" style="color: indianred">grid_view</i></button>
            <button title="Asset Viewer" onclick="ui.openAppIframe('asset-viewer')"><i class="material-icons">view_in_ar</i></button>
        </li>
        <li title="Camera"><button onclick="ui.toggleMenuCamera()">CAMERA</button></li>
        <li title="Environment"><button onclick="ui.toggleMenuEnv()">ENV.</button></li>
        <li title="Material"><button onclick="ui.toggleMenuMaterial()">MATERIAL</button></li>
        <li title="Texture"><button onclick="ui.toggleMenuTexture()">TEXTURE</button></li>
        <li title="Render"><button onclick="ui.toggleMenuRender()">RENDER</button></li>
    </ul>
    <ul id="toolbar_C">
        <li onclick="ui.clearAllMenus('both'); ui.setMode(0)" class="mode mode_select">MODEL</li>
        <li onclick="ui.clearAllMenus('both'); ui.setMode(1)" class="mode">BAKE</li>
        <li onclick="ui.clearAllMenus('both'); ui.setMode(2)" class="mode">RENDER</li>
    </ul>
    <ul id="toolbar_C_mem">
        <li onclick=""><b>SAVE</b></li>
        <li onclick=""><b>LOAD</b></li>
        <li onclick="memory.undo()"><b>UNDO</b></li>
        <li onclick="memory.redo()"><b>REDO</b></li>
    </ul>
    <ul class="menu_R" id="menu-about">
        <li onclick="ui.toggleMenuAbout()"><i class="material-icons">exit_to_app</i> <span>ABOUT</span></li>
        <li class="category">HELP</li>
        <li><button onclick="ui.toggleHelp()">Documentation</button></li>
        <li class="spacer"></li>
        <li>
            <select onchange="project.loadFromUrl(this.options[this.selectedIndex].value)">
                <option value="">MagicaVoxel</option>
                <option value="samples/mv_character_cat.vbx">Character Cat</option>
                <option value="samples/mv_tankdestroyer_arsgametm.vbx">Tank Destroyer @arsgametm</option>
                <option value="samples/mv_odyssey_kluchek.vbx">Odyssey @kluchek</option>
                <option value="samples/mv_countryhouse_tnrmnv.vbx">Country House @tnrmnv</option>
            </select>
            <select onchange="project.loadFromUrl(this.options[this.selectedIndex].value)">
                <option value="">Tests</option>
                <option value="samples/test_archinterior.vbx">Arch Interior</option>
                <option value="samples/test_boxtool.vbx">Box Tool</option>
                <option value="samples/test_boxpaint.vbx">Box Paint</option>
                <option value="samples/test_filltool.vbx">Fill Tool</option>
                <option value="samples/test_isometric.vbx">Isometric</option>
                <option value="samples/test_pulltools.vbx">Pull Tools</option>
                <option value="samples/test_visibility.vbx">Visibility</option>
                <option value="samples/test_symmetry.vbx">Symm Odd</option>
                <option value="samples/test_symmetry2.vbx">Symm Even</option>
                <option value="samples/test_bakecolors.vbx">Bake Colors</option>
                <option value="samples/test_pixelmonk.vbx">Pixel Monk 2D</option>
                <option value="samples/test_faceuv.vbx">Face UV</option>
                <option value="samples/test_texture.vbx">Texture</option>
            </select>
        </li>
        <li class="spacer"></li>
        <li class="about">
            <label>Version</label>
            <br>3.9.5b Feb-2023
            <br>&#8627; <a href="https://github.com/nimadez/voxel-builder/">Repository</a>
            <br><label>Developer</label>
            <br>&#8627; <a href="https://nimadez.github.io/">Nima Dezfuli</a>
            <br>2019
        </li>
        <li class="category">DEV STUFF</li>
        <li><button onclick="ui.toggleDebugMode()">Debug Layer [O]</button></li>
    </ul>
    <ul class="menu_R" id="menu-prefs">
        <li onclick="ui.toggleMenuPrefs()"><i class="material-icons">exit_to_app</i> <span>PREFERENCES</span></li>
        <li class="category">GENERAL</li>
        <li><input type="checkbox" id="input-prefs-nointro" onclick="preferences.setNoIntro(this.checked)"> <label for="input-prefs-nointro">No Intro</label></li>
        <li><input type="checkbox" id="input-prefs-fullscreen" onclick="toggleFullscreen()"> <label for="input-prefs-fullscreen">Fullscreen</label></li>
        <li class="category">ADDONS</li>
        <li><button onclick="window.open('https://nimadez.github.io/voxel-builder/apps/asset-viewer/', '_blank').focus();">Asset Viewer</button></li>
        <li><button onclick="window.open('https://nimadez.github.io/voxel-builder/apps/pixel-monk/', '_blank').focus();">Pixel Monk</button></li>
        <li class="category">PERFORMANCE</li>
        <li><button onclick="clearCache()">Clear Cache</button></li>
    </ul>
    <ul class="menu_R" id="menu-file">
        <li onclick="ui.toggleMenuFile()"><i class="material-icons">exit_to_app</i> <span>FILE</span></li>
        <li class="spacer"></li>
        <li class="category">PROJECT</li>
        <li><input id="input-project-name" type="text" value="null" minlength="3" maxlength="100" spellcheck="false" placeholder="Project Name"></li>
        <li class="spacer"></li>
        <li><button onclick="project.newBox()">New</button></li>
        <li class="spacer"></li>
        <li><button onclick="document.getElementById('openfile_vbx').click()">Load</button></li>
        <li><button onclick="project.save()">Save As...</button></li>
        <li><button onclick="document.getElementById('openfile_vbx_imp').click()">Import Bakes</button></li>
        <li class="spacer"></li>
        <li><button onclick="document.getElementById('openfile_vox').click()">Load<br>MagicaVoxel</button></li>
        <li class="category">EXPORT</li>
        <li><button onclick="project.exportVoxels()">Export Voxels</button></li>
        <li><button onclick="project.exportBakes()">Export Bakes</button></li>
        <li class="spacer"></li>
        <li><button onclick="createScreenshot()">Screenshot</button></li>
    </ul>
    <ul class="menu_R" id="menu-generator">
        <li onclick="ui.toggleMenuGenerator()"><i class="material-icons">exit_to_app</i> <span>GENERATOR</span></li>
        <li class="category">GRID</li>
        <li>
            <label>&nbsp;X&nbsp;</label> <input id="input-grid-x" type="number" value="10" min="4" max="100"><br>
            <label>&nbsp;Y&nbsp;</label> <input id="input-grid-y" type="number" value="10" min="1" max="100"><br>
            <label>&nbsp;Z&nbsp;</label> <input id="input-grid-z" type="number" value="10" min="4" max="100"><br>
            <button onclick="generator.createGrid(true)">Grid (Fill)</button>
            <button onclick="generator.createGrid(false)">Grid (Empty)</button>
            <button onclick="generator.createSphere()">Sphere</button>
        </li>
        <li class="category">ISOMETRIC</li>
        <li>
            <label>&nbsp;X Y Z&nbsp;</label> <input id="input-isometric-size" type="number" value="20" min="2" max="100"><br>
            <button onclick="generator.createIsometric()">Isometric</button>
        </li>
        <li class="category">TERRAIN</li>
        <li>
            <label>&nbsp;X&nbsp;</label> <input id="input-terrain-x" type="number" value="40" min="3" max="100"><br>
            <label>&nbsp;Y&nbsp;</label> <input id="input-terrain-y" type="number" value="10" min="1" max="20"><br>
            <label>&nbsp;Z&nbsp;</label> <input id="input-terrain-z" type="number" value="40" min="3" max="100"><br>
            <button onclick="generator.createTerrain()">Terrain</button>
        </li>
    </ul>
    <ul class="menu_R" id="menu-voxelizer">
        <li onclick="ui.toggleMenuVoxelizer()"><i class="material-icons">exit_to_app</i> <span>VOXELIZER</span></li>
        <li class="category">3D VOXELIZER</li>
        <li><button onclick="document.getElementById('openfile_obj').click()">Upload OBJ</button></li>
        <li><button onclick="voxelizer.pasteObjBase64()">Paste Base64</button></li>
        <li><button onclick="voxelizer.pasteObjUrl()">Paste URL</button></li>
        <li><label>Scale&nbsp;&nbsp;</label> <input type="number" id="input-voxelizer-scale" value="40" min="5" max="100"></li>
        <li><label>Dense</label> <input type="number" id="input-voxelizer-dense" value="20" min="1" max="200"></li>
        <li class="category">2D VOXELIZER</li>
        <li><button onclick="document.getElementById('openfile_img').click()">Upload Image</button></li>
        <li><button onclick="voxelizer.pasteBase64Image()">Paste Base64</button></li>
        <li><label>Ratio</label> <input type="number" id="input-voxelizer-ratio" value="5.0" min="0.1" max="20" step="0.1"></li>
        <li><input type="checkbox" id="input-voxelizer-zup" checked> <label for="input-voxelizer-zup">Z-Up</label></li>
    </ul>
    <ul class="menu_R" id="menu-symmetry">
        <li onclick="ui.toggleMenuSymmetry()"><i class="material-icons">exit_to_app</i> <span>SYMMETRY</span></li>
        <li class="category">AXIS</li>
        <li><button id="btn-symm-axis" onclick="symmetry.switchAxis()">None</button></li>
        <li class="category">SYMMETRIZE</li>
        <li onclick="symmetry.symmetrizeVoxelPositions(1)"><button>Positive (+) To<br>Negative (-)</button></li>
        <li onclick="symmetry.symmetrizeVoxelPositions(-1)"><button>Negative (-) To<br>Positive (+)</button></li>
        <li class="category">FUNCTIONS</li>
        <li onclick="symmetry.mirrorVoxelPositions()"><button>Mirror</button></li>
        <li onclick="symmetry.deleteHalfVoxels(-1)"><button>Delete Half (+)</button></li>
        <li onclick="symmetry.deleteHalfVoxels(1)"><button>Delete Half (-)</button></li>
    </ul>
    <ul class="menu_R" id="menu-model">
        <li onclick="ui.toggleMenuModel()"><i class="material-icons">exit_to_app</i> <span>MODELING</span></li>
        <li class="category">DRAW</li>
        <li><button onclick="tool.toolSelector('add')" class="tool_add">Add</button></li>
        <li><button onclick="tool.toolSelector('remove')" class="tool_remove">Remove</button></li>
        <li><button onclick="tool.toolSelector('fill')" class="tool_fill">Fill (slow)</button></li>
        <li class="category">BOX</li>
        <li><button onclick="tool.toolSelector('boxadd')" class="tool_boxadd">Box Add</button></li>
        <li><button onclick="tool.toolSelector('boxrem')" class="tool_boxrem">Box Remove</button></li>
        <li class="spacer"></li>
        <li><label>Height</label> <input id="input-boxtool-height" type="number" value="0" min="0" max="100"></li>
        <li class="category">TRANSFORM</li>
        <li><button onclick="tool.toolSelector('pull')" class="tool_pull">Pull Voxel</button></li>
        <li><button onclick="tool.toolSelector('pullcolor')" class="tool_pullcolor">Pull Color</button></li>
        <li><input type="checkbox" id="input-helper-workplane" onclick="helper.toggleWorkplane()"> <label for="input-helper-workplane">Use Workplane</label></li>
    </ul>
    <ul class="menu_R" id="menu-paint">
        <li onclick="ui.toggleMenuPaint()"><i class="material-icons">exit_to_app</i> <span>PAINTING</span></li>
        <li class="category">COLORIZE</li>
        <li><button onclick="tool.toolSelector('paint')" class="tool_paint">Paint</button></li>
        <li><button onclick="tool.toolSelector('boxpaint')" class="tool_boxpaint">Box Paint</button></li>
        <li class="category">TOOLS</li>
        <li><button onclick="tool.toolSelector('bucket')" class="tool_bucket">Bucket</button></li>
        <li><button onclick="tool.toolSelector('eyedrop')" class="tool_eyedrop">Eyedropper</button></li>
    </ul>
    <ul class="menu_R" id="menu-voxels">
        <li onclick="ui.toggleMenuVoxels()"><i class="material-icons">exit_to_app</i> <span>VOXELS</span></li>
        <li class="category">DISPLAY</li>
        <li><input type="checkbox" id="input-voxels-onion" onclick="builder.toggleOnionSkin()"> <label for="input-voxels-onion">Onion Skin</label></li>
        <li class="category">TOPOLOGY</li>
        <li onclick="builder.normalizeVoxelPositions(true)"><button>Normalize<br>Voxel Positions</button></li>
        <li onclick="builder.reduceVoxels()"><button>Reduce Voxels</button></li>
        <li onclick="builder.removeDuplicatesFunc()"><button>Kill Duplicates</button></li>
        <li class="category">VISIBILITY</li>
        <li><button onclick="tool.toolSelector('boxhide')" class="tool_boxhide">Box Hide</button></li>
        <li><button onclick="tool.toolSelector('hidecolor')" class="tool_hidecolor">Hide Color</button></li>
        <li class="spacer"></li>
        <li><button onclick="builder.invertVisibility()">Invert Visibility</button>
        <li><button onclick="builder.setVoxelsVisibility(true)">Unhide All</button>
        <li><button onclick="builder.deleteHidden()">Delete Hidden</button>
    </ul>
    <ul class="menu_R" id="menu-bakery">
        <li onclick="ui.toggleMenuBakery()"><i class="material-icons">exit_to_app</i> <span>BAKERY</span></li>
        <li class="category">ADD BAKE</li>
        <li><button onclick="bakery.newBake()">New Bake</button></li>
        <li><button onclick="tool.toolSelector('bakecolor')" class="tool_bakecolor">Bake Color</button></li>
        <li><button onclick="tool.toolSelector('boxbake')" class="tool_boxbake">Box Bake</button></li>
        <li class="category">BATCH BAKE</li>
        <li><button onclick="bakery.bakeAllColors()">Bake All Colors</button></li>
        <li class="category">CLEAR</li>
        <li><button onclick="bakery.clearBakes(true)">Clear Bakes</button></li>
        <li class="category">OPTIONS</li>
        <li><input type="checkbox" id="input-bakery-uvs"> <label for="input-bakery-uvs">Per-Face UVs</label></li>
    </ul>
    <ul class="menu_R" id="menu-bakes">
        <li onclick="ui.toggleMenuBakes()"><i class="material-icons">exit_to_app</i> <span>BAKES</span></li>
        <li class="category">REPLICATE</li>
        <li><button onclick="bakery.cloneSelected()">Clone</button></li>
        <li><button onclick="bakery.instanceSelected()">Instance</button></li>
        <li><button onclick="bakery.deleteSelected()">Delete</button></li>
        <li class="category">MERGE TOOL</li>
        <li><button class="tool_merge" onclick="toolBakery.toolSelector('merge')">Pick</button></li>
        <li><button onclick="toolBakery.mergeBakes()">Merge Selected</button></li>
        <li><button onclick="toolBakery.cancelTools()">Cancel</button></li>
        <li class="category">MESH</li>
        <li><button onclick="bakery.updateVertexColors()">Set Vertex Colors</button></li>
    </ul>
    <ul class="menu_L" id="menu-camera">
        <li onclick="ui.toggleMenuCamera()"><i class="material-icons">exit_to_app</i> <span>CAMERA</span></li>
        <li class="category">FOCUS</li>
        <li><label>Field of View</label> <input id="input-camera-fov" oninput="camera.setFov(this)" type="range" value="0.8" min="0.1" max="1.0" step="0.01"></li>
        <li><button onclick="camera.frame()">Frame Camera</button></li>
        <li class="category">VIEW</li>
        <li><button id="btn-ortho" onclick="camera.switchOrtho()">Perspective</button></li>
        <li class="category">CONTROLS</li>
        <li><input type="checkbox" id="input-autorotate" onclick="camera.toggleCameraAutoRotation()"> <label for="input-autorotate">Auto Rotate</label></li>
    </ul>
    <ul class="menu_L" id="menu-env">
        <li onclick="ui.toggleMenuEnv()"><i class="material-icons">exit_to_app</i> <span>ENVIRONMENT</span></li>
        <li class="category">BACKGROUND</li>
        <li><input type="checkbox" id="input-env-bgcheck" onclick="scene.autoClear = this.checked"> <label for="input-env-bgcheck">Enable</label></li>
        <li><input type="color" id="input-env-background" value="#7882A0"></li>
        <li class="category">HDRI</li>
        <li><button onclick="document.getElementById('openfile_hdr').click()">Load HDRI</button></li>
        <li><button onclick="hdri.unloadHDR(true)">Unload</button></li>
        <li><input type="checkbox" id="input-hdri-toggle" onclick="hdri.toggleSkybox(this.checked)"> <label for="input-hdri-toggle">Display HDRI</label></li>
        <li><input type="range" id="input-hdri-blur" value="0.08" min="0" max="1.0" step="0.01" oninput="hdri.setBlurAmount(this.value)"></li>
        <li class="category">LIGHT</li>
        <li><input type="color" id="input-env-lightcolor" value="#CCCCCC"></li>
        <li><label>Intensity</label><input type="range" value="0.4" min="0" max="1.0" step="0.01" oninput="updateLightIntensity(this.value)"></li>
        <li><label>Angle</label><input type="range" value="120" min="0" max="360" step="10" oninput="updateLightAngles(this.value)"></li>
        <li><input type="checkbox" id="input-display-shadows" onclick="enableShadows(this.checked)" checked> <label for="input-display-shadows">Shadows</label></li>
    </ul>
    <ul class="menu_L" id="menu-material">
        <li onclick="ui.toggleMenuMaterial()"><i class="material-icons">exit_to_app</i> <span>PBR MATERIAL</span></li>
        <li class="category">UPDATE</li>
        <li><button onclick="bakery.getMaterial()">Get Material<br>and Color</button>
        <li><input type="checkbox" id="input-material-autoupdate"> <label for="input-material-autoupdate">Auto Update</label></li>
        <li class="category">PROPERTIES</li>
        <li><label>Roughness</label><input id="input-material-roughness" oninput="bakery.setMaterial('roughness')" type="range" value="0.95" min="0" max="1.0" step="0.01"></li>
        <li><label>Metallic</label><input id="input-material-metallic" oninput="bakery.setMaterial('metallic')" type="range" value="0.4" min="0" max="1.0" step="0.01"></li>
        <li><label>Alpha</label><input id="input-material-alpha" oninput="bakery.setMaterial('alpha')" type="range" value="1.0" min="0.1" max="1.0" step="0.01"></li>
        <li><label>Emissive</label><input type="color" id="input-material-emissive" value="#000000"></li>
        <li class="category">REPLICATE</li>
        <li><button onclick="bakery.setMaterial('all')">Assign To<br>Selected</button>
    </ul>
    <ul class="menu_L" id="menu-texture">
        <li onclick="ui.toggleMenuTexture()"><i class="material-icons">exit_to_app</i> <span>TEXTURE</span></li>
        <li class="category">PATTERN</li>
        <li class="pattern">
            <button onclick="material.setPBRTexture(0); bakery.replaceTexture()">Solid</button>
            <button onclick="material.setPBRTexture(1); bakery.replaceTexture()">Outline</button>
            <button onclick="material.setPBRTexture(2); bakery.replaceTexture()">Grid</button>
            <button onclick="material.setPBRTexture(3); bakery.replaceTexture()">Check</button>
        </li>
        <li class="category">IMPORT</li>
        <li><button onclick="document.getElementById('openfile_tex').click()">Add Texture</button></li>
        <li class="spacer"></li>
        <li id="texturepresets"></li>
        <li ondrop="material.deleteTexture(event)" ondragover="event.preventDefault()"><div class="dropzone">drop texture<br>here to delete</div></li>
        <li class="category">REPLICATE</li>
        <li><button onclick="bakery.replaceTextureAll()">Apply To All</button>
    </ul>
    <ul class="menu_L" id="menu-render">
        <li onclick="ui.toggleMenuRender()"><i class="material-icons">exit_to_app</i> <span>RENDER</span></li>
        <li class="category">POST PROCESS</li>
        <li><label>Contrast</label> <input id="input-pipeline-contrast" oninput="pipeline.updateProps()" type="range" value="0.8" min="0" max="3.0" step="0.01"></li>
        <li><label>Exposure</label> <input id="input-pipeline-exposure" oninput="pipeline.updateProps()" type="range" value="1.8" min="0" max="3.0" step="0.01"></li>
        <li><label>Hue</label> <input id="input-pipeline-hue" oninput="pipeline.updateProps()" type="range" value="0" min="0" max="360" step="1"></li>
        <li class="spacer"></li>
        <li><input type="checkbox" id="input-pipeline-bloom" onclick="pipeline.init()"> <label for="input-pipeline-bloom">Enable Bloom</label></li>
        <li><input type="checkbox" id="input-pipeline-dof" onclick="pipeline.init()"> <label for="input-pipeline-dof">Enable DOF</label></li>
        <li><input disabled id="input-pipeline-dofdist" oninput="pipeline.updateProps()" type="range" value="450" min="0" max="1000" step="1"></li>
        <li><label>Sharpen</label> <input id="input-pipeline-sharpen" oninput="pipeline.updateProps()" type="range" value="0.2" min="0" max="1.0" step="0.01"></li>
        <li><label>Chromatic Aberr.</label> <input id="input-pipeline-chromatic" oninput="pipeline.updateProps()" type="range" value="1" min="0" max="50" step="1"></li>
    </ul>
    <ul id="hover">
        <li title="Free camera" class="tool_camera" onclick="tool.toolSelector('camera')" onpointerdown="ui.dragElement(this)"><i class="material-icons">control_camera</i></li>
        <li title="Box Paint" class="tool_boxpaint" onclick="tool.toolSelector('boxpaint')"><i class="material-icons">imagesearch_roller</i></li>
        <li title="Box Add" class="tool_boxadd" onclick="tool.toolSelector('boxadd')"><i class="material-icons">add</i></li>
        <li title="Eyedropper" class="tool_eyedrop" onclick="tool.toolSelector('eyedrop')"><i class="material-icons">colorize</i></li>
        <li title="Bucket" class="tool_bucket" onclick="tool.toolSelector('bucket')"><i class="material-icons">format_color_fill</i></li>
        <li title="Box Remove" class="tool_boxrem" onclick="tool.toolSelector('boxrem')"><i class="material-icons">remove</i></li>
        <li title="Paint" class="tool_paint" onclick="tool.toolSelector('paint')"><i class="material-icons">brush</i></li>
        <li title="Add" class="tool_add" onclick="tool.toolSelector('add')"><i class="material-icons">create</i></li>
        <li title="Remove" class="tool_remove" onclick="tool.toolSelector('remove')"><i class="material-icons">clear</i></li>
    </ul>
    <div id="colorpicker"><input type="color" id="input-color" value="#6B8EB6"></div>
    <div id="axisview-hitbox" onclick="camera.frame()"></div>
    <div id="btn-helper-symmetry" title="Symmetry" onclick="symmetry.switchAxis()">S</div>
    <div id="btn-helper-workplane" title="Workplane" onclick="helper.toggleWorkplane()"><i class="material-icons">border_inner</i></div>
    <!-- dynamic -->
    <div id="marquee"></div>
    <div id="palette"><canvas id="canvas_palette"></canvas></div>
    <div id="reticle"><i class="material-icons">add</i><span></span><span></span></div>
    <div id="appiframe"><iframe id="aiframe"></iframe></div>
    <div id="info"><span>0</span> FPS | <span>0</span> | <span>0</span></div>
    <div id="loadingscreen"><div class="logo"><div class="cube"><div class="cube-faces"><div class="cube-face bottom"></div><div class="cube-face top"></div><div class="cube-face left"></div><div class="cube-face right"></div><div class="cube-face back"></div><div class="cube-face front"></div></div></div>
    </div><div class="progress">- LOADING -</div></div>
    <div id="confirm"><span>Are you sure?</span> <button>Cancel</button> <button>Ok</button></div>
    <div id="confirmblocker"></div>
    <div id="notifier"></div>
    <div id="help"></div>
    <div id="intro"></div>
    <!-- hidden -->
    <input style="display: none" type="file" id="openfile_vbx" accept=".vbx" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_vbx_imp" accept=".vbx" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_vox" accept=".vox" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_obj" accept=".obj" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_glb" accept=".glb" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_img" accept=".jpg,.png,.svg" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_tex" accept=".jpg,.png" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_hdr" accept=".hdr" onclick="this.value = null">

<script>
    // -------------------------------------------------------
    // Initialize

    const PARTICLE = "data:image/png;base64,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";
    const texenv = "https://nimadez.github.io/voxel-builder/assets/venice_sunset_1k.hdr";
    const texpat0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAMAAABFaP0WAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4ODg4NzQ1MjgxNEExMUVEQjVDQTlGMzY0ODY0NzdERiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4ODg4NzQ1MzgxNEExMUVEQjVDQTlGMzY0ODY0NzdERiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg4ODg3NDUwODE0QTExRURCNUNBOUYzNjQ4NjQ3N0RGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg4ODg3NDUxODE0QTExRURCNUNBOUYzNjQ4NjQ3N0RGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+xCfx0wAAAAZQTFRF////AAAAVcLTfgAAAA5JREFUeNpiYAABgAADAAAGAAHgQhFOAAAAAElFTkSuQmCC";
    const texpat1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAADwCAMAAACg0xNxAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MURGNUY4RDQ4MTRBMTFFRDg1OTZGOUQyMjQ2RDM0M0IiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MURGNUY4RDM4MTRBMTFFRDg1OTZGOUQyMjQ2RDM0M0IiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjFlZjEwNWVjLTQxZTMtZDQ0NS04NjUzLTA4NTlhYmMzMmY4NSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7Mp3ODAAAABlBMVEXu7u7///8o06qaAAAAaElEQVR42uzZMQ0AAAjAMPBvGgc8cJDQCaiBRbws9wICgUAgEAgEAoFAIBAIBAKBQCAQOAflpwCBQCAQCAQCgUAgEAgEAoFAIBAI7EH5KUAgEAgEAoFAIBAIBAKBQCAQCAQCe/B2JcAAIghB7N/vJckAAAAASUVORK5CYII=";
    const texpat2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAADwCAMAAACg0xNxAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NUE0MjE1NEY4MTRBMTFFRDgwMkJFMDA0NDAyMEZBMjQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NUE0MjE1NEU4MTRBMTFFRDgwMkJFMDA0NDAyMEZBMjQiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjcyNzA3OTRhLTljOTgtNzM0ZC04MjgxLTZkNjBjOTljYTM5ZSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5nAPaYAAAAD1BMVEX6+vrw8PDv7+/u7u7////hEbC4AAAAhElEQVR42uzZsQ3AIAxFQRPYf2aUDSw5RcD3a+tq0Iv58eIIcCU2UlcLCAQCgUAgEAgEvu/sxJ7UVfgFAIFAIBAIBAKBPcGGtUJPAQKBQCAQCAQCu4F6ChAIBAKBQCAQCCyC8oeeAgQCgUAgEAgEXg/qKUAgEAgEAoFAILAI/jsubAEGAJbMGzlAxOE3AAAAAElFTkSuQmCC";
    const texpat3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAADwCAMAAACg0xNxAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NkJEOEMzNzI4MTRBMTFFRDg4QTJGODA0OTc0NEY4OEQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NkJEOEMzNzE4MTRBMTFFRDg4QTJGODA0OTc0NEY4OEQiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmM0YmQ5NDcyLWM2YWEtNjc0ZC05ODMzLTZjOGE1ZDhhYTg3MyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6Wa8daAAAACVBMVEXu7u7////19fVT5JFBAAAAc0lEQVR42uzZsREAMAgDMWD/oVnBTYokcs2JAb7qy02yjgYEAoFAIBAIBAJPgNFp9HWAQCAQCAQCgUDgFaDpKUAgEAgEAoFAIFBPAQKBQCAQCAQCgXqKngIEAoFAIBAIBAL1FCAQCAQCgUAgEPhuT1kBBgAiG2LjsAHS6QAAAABJRU5ErkJggg==";
    const tex0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDc0OUI1NzM1RkYxMTFFRDlENDNDMTVFMEE4NDM4N0QiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDc0OUI1NzI1RkYxMTFFRDlENDNDMTVFMEE4NDM4N0QiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY2MjA4ZTcyLWY5NzctNDM0Mi05MDk0LTdkYWQwOTU3NDk2ZCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6/aB5VAAAAeFBMVEVvr0VhoTdoqD5pqT9trUNqqkB1tUtiojiHh4eKuVpsbGxrq0F0tEqDslN0WESQv2CTwmOcy2ySwWJ/v1VgoDaNvF1QkCaXxmdkpDqBsFFwsEZxsUdXly1mpjxnpz1fnzVzs0l+vlR2tkxsrEK5hVxZPSmWbEp5VTrV5Zr8AAABOElEQVR42tSPaXLDIAyFBXbiLE6T7iugxYL737ASzrS5QH907NEgwfveE4wkQ94wSYGUkDMcWQJaO8UBZS9bmBkkQRHiTR4Cj7AV5FOIXIgxSGYYGQZxBgIzcgTKZAJjyHQy1tZeDDcuheCYzSWn0xSFBX3Mpv1xmdxlLxRiKFSQJUdjhJXBPensDEAzOkdakxJToiuDr0klXaIVwr3IBAmREtDtLpSRIhVBDGQuM2P63fal53g/aZzK5ezbHuFZ798G/dD58eFVv54U9KD6qapFR22qDWqri9ZmZz20aoOm1WbW2qy1tsBidWeHxX+7Aj/bG3vUawWv9mnzvjmjutrlXWeS2vVVFzOru9Yl1W4OJjF7dds+aVeRS9qdE3VRU7qLLgbXnmK19Ri7tqZYGf81+l9AvwUYAFsRXgO8yBShAAAAAElFTkSuQmCC";
    const tex1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA21pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OTBBOTEyQTk2OTFDMTFFREJCQTQ4MEQxMEI3NzhFRUUiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OTBBOTEyQTg2OTFDMTFFREJCQTQ4MEQxMEI3NzhFRUUiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjEyNGM5YzNiLTkzYzUtMTQ0OC1iNDhkLWQ5MjliMmE1NTI2NCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2OEMyMEU3NjYwMzkxMUVEQkUwRjg5QzQ0NzlGMTcwNyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PrymvYUAAAAwUExURTAgLEk8RbKqqmFVXYp9gv///x0dHSwsLC0tLS4uLi8vLzAwMDExMTIyMjMzMzk5OXQCvBgAAAAGdFJOU///////ALO/pL8AAADJSURBVHja1JIJFsMgCERHxyyatL3/bQuoaNJcoCjy/AZEAuJVEmK6CBWQpmoaSIvMyCX+HUjySJmm/H1tWdcyZC3IH5JBhq3YARIBIQTYyAJso0oIwsG2NRWWFTQoy3t2US04wwzkljyfq8s+n2tQi9FFY7w0H9QrZNmuMfSsiMJVXID5FmRsJ064lOOpHaQS1ghmDGhVUzMVeD85qP4daPnNX7/pv0EqxNF0Zm+g+ow8Oux5dODXsomDW6aWaGrmoR08QJOvAAMAz54JCo4zaZIAAAAASUVORK5CYII=";
    const tex2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1Rjk4MTlBNTY5MTkxMUVEODk0QUY2MTk2RkMzRkQ5QSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1Rjk4MTlBNjY5MTkxMUVEODk0QUY2MTk2RkMzRkQ5QSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVGOTgxOUEzNjkxOTExRUQ4OTRBRjYxOTZGQzNGRDlBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjVGOTgxOUE0NjkxOTExRUQ4OTRBRjYxOTZGQzNGRDlBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+kl/wtwAAABhQTFRFZSwoXSQkpmFFjkEwdTAsw4JVNBAcTRwgnCGS7gAAAKxJREFUeNrsklsSQyEIQ+Hy2v+OS0At3ukSmh/GY8TISO7swZHKGu7k+tjTQnUKffRIjAscg1gdOR4TC+ICZRHrI5bARLGEI9qBhb7B5TBrz24qKdtNax8CqBxSUpGdw44AvDeXCUfw6H5+Vv8JUhxEADWgnhjzF8QC4ROkaM0UOOaQUaiaDtBN68IJrhwdbOSYoK7NpneO7HHnqFtmjlew9R1Wjv//GN/hI8AAMpwNYRsTIbAAAAAASUVORK5CYII=";
    const tex3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozNDM5YTY3ZS1jZmQwLTBkNDAtYjcxZC02MDFjODZkYWYzZjYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QjkwMjFBNjc2Q0Q3MTFFRDhFRTVGNjNCMTNBODJEMzkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QjkwMjFBNjY2Q0Q3MTFFRDhFRTVGNjNCMTNBODJEMzkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJlOTlkZGI4LWUxN2UtNjc0NC04YmIzLTQ1YWNhNjBmMTY2YiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozNDM5YTY3ZS1jZmQwLTBkNDAtYjcxZC02MDFjODZkYWYzZjYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4OtNUFAAAACVBMVEW77fCr3uajzNZQMo+CAAAAPklEQVR42mJgZGRCAoyMDExMDIwILpAHY8BIBpgcTCsDFjMYcZnBQJEZDKS4gwGfO0jwy2h4jIYHTB1AgAEATlgFNRLiuuEAAAAASUVORK5CYII=";
    const tex4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0VGMEM5QUU4MTRCMTFFREIxQzRBNTlENjVEQzFCRTYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0VGMEM5QUQ4MTRCMTFFREIxQzRBNTlENjVEQzFCRTYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmNjYmFmOTc0LWI2YWItZjg0OC04ZWZkLTQ1YmI1ZDM3Yjk2MyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5nyFTOAAABgFBMVEVNWTSSEgJWYUV5entiaVeUkpU8RS1xcXGXKxGlFQR0dHSFCwHkIhKtFQR0hlDaHgc2PShUV01UZj2CEQTXIgt8EQR6RCdiY19yCwN7DQNubW6EgYRtDAKBfoKkGASVCgBabTuNEQBcW1lidUOzGQtWAgF+fH5rfUyqGQRta21wc2uZFQZTUlN+Qzi4HAxwbnCIEQJqamqDRj1TXFGlEwmyFQVjBQFSXjyPEQWXFQFNTU2bFgeaFwKeFgWeFQKqFQlBQD9wBwBqa2KsHQliFQ1UaDhATSymEAJycHVrBgFOU0N0dnKRGAKJhoqNGQlxdHGMEgrfJhC/GQhua3CSj5Jna2ZfcEJGTzWYEwRYDwuZEAWWFAh+DQh3dnacDwKXlJdoCQBYXFNXWVehEgVOAABecD2RkJCpHRJ7fndnZ2ezGxB4eHh9f35UYzqNFAdvcHR3BwB9IA5+gIBsa21sbGxuaWxub2uKbldcZE9nfER3e3OuJQ2XGQe6FQXHJRNtCgADdoGmAAACvElEQVR42iyQC1PaQBSFb4oQSYg8ApIFEtny1IAEKwhCEERF8VXQAoIRBLSlCsWqrW1t89e7o97ZmZ37zd6z51ywu080zQtzfTp8aDQaT6HpfmTEG2+jP0ouJrSwBjB20wSM1x1j/yatPQE47hlG9HZtjsYm0xw3AK78D4QYi8njhKkRmYP3nm3/NsNcF3c99O1aYA5iDJ0Y3TPh4ihpCkTIi9j6a8XGPxgargIQS4je61PjYfHKT2s34RmAtV+Nk32xa/JH/EsGLUy+/RbRHhijzeGPLDVniI+l+/3Eiw/HDL1PRi7dD17DSOzafu+4GZv9O/Q9DK15RZN998unkcEEYH9kPKaq2OhrNG1rOgIAbk/C/uSO9J+q9uo7xxj67kXRsBju2o6JhumDgWRhGM3r3bncvU2ODM1tqN4zJyyIgb7Bc2zbyXIA2WTiD2va67tsRSWW46BmGQosP3SFSnovE7RYIMgOh+n0yykN02wJnCg0VNIhvafrvRBLDcCJeSXdIy0pgcq1wal0yqzvpWcxbnHgfJb/sXzpSPG5MKbyBKjtFl/qseWSwFM5qU6ARGGko48lpGAl8xdq+UKLEIyQQrXwxAy1tkrJLYwxomRpVa1AbVnKXljYVnbakaJliVhXCoWatWLmKlw0GpVS8HOeVHwlHo+Te2VlHs44rv6X4waDSqpi5bgKnJmj9Q11wsqyat4oy1nYMpejksy7fAhT6lGHgFRUymVcCPFI6QirA7irR2Uk+AQkCOi8HQzCLHeU4YXX9HtfJ1mYNZ8rb0DnMX6G2Quqdf4GplimCMhLOV7wTXXflCTKEw1zcJVkfXbpCqZklgCyD5dPR591RHUOnHDHlXNkH4jvlcjEVIati1wrlyH6yoRSByoLZ9ZUXhksU5ifqoVyQYWtzEF2w7qcVxcWJEnKL/wXYAD7zZrdqiCQKgAAAABJRU5ErkJggg==";
    
    const COL_ORANGE = '#FFA500';
    const COL_AQUA = '#00FFFF';
    const COL_BAKERY = '#BBBBBB';
    const COL_DELETE = '#FF0000';
    const COL_HIDE = '#FFFF00';
    const COL_BAKE = '#00FFFF';

    const PI2 = Math.PI * 2;
    const PIH = Math.PI / 2;
    const MAXAMOUNT = 64000;
    const FPS_TOOLMOVE = 1000 / 60;
    const viewAxes = [];

    let MODE = 0; // model|bake|render
    let currentColor = document.getElementById('input-color').value.toUpperCase();
    let isRenderAxisView = true;
    let azimuth = null;

    const canvas = document.getElementById('canvas_render');
    const canvasP = document.getElementById('canvas_palette');

    const engine = new BABYLON.Engine(canvas, true, {});
    engine.disablePerformanceMonitorInBackground = true;
    engine.disableWebGL2Support = false;
    engine.preserveDrawingBuffer = false;
    engine.premultipliedAlpha = false;
    engine.enableOfflineSupport = false;
    engine.doNotHandleContextLost = true;
    engine.loadingScreen = new CustomLoadingScreen();
    engine.displayLoadingUI();

    const camera = new Camera();
    const scene = createScene(engine);
    const sceneAxisView = createAxisViewScene(engine);

    const ui = new UserInterface(scene);
    const uix = new UserInterfaceAdvanced(scene);
    
    const hdri = new HDRI(scene);
    const pipeline = new Pipeline(scene);
    const material = new Material(scene);

    const builder = new Builder(scene);
    const bakery = new Bakery(scene);

    const palette = new Palette();
    const helper = new Helper(scene, sceneAxisView);
    const tool = new Tool(scene);
    const toolBakery = new ToolBakery(scene);
    const symmetry = new Symmetry();

    const preferences = new Preferences();
    const project = new Project(scene);
    const storage = new Storage();
    const memory = new Memory();

    const voxelizer = new Voxelizer();
    const generator = new Generator();

    // intro
    scene.executeOnceBeforeRender(() => {
        preferences.init();
        hdri.initHDRI();
    }, 0);

    scene.executeWhenReady(() => {
        project.newBox(8, '#6480B6');
        engine.hideLoadingUI();
    }, 0);

    // render loops
    engine.runRenderLoop(() => {
        scene.render();
    });

    scene.registerAfterRender(() => {
        if (isRenderAxisView) {
            sceneAxisView.render();
            if (MODE !== 2) {
                sceneAxisView.activeCamera.alpha = scene.activeCamera.alpha;
                sceneAxisView.activeCamera.beta = scene.activeCamera.beta;
            } else {
                azimuth = BABYLON.Spherical.FromVector3(camera.camera2.position);
                sceneAxisView.activeCamera.alpha = azimuth.phi;
                sceneAxisView.activeCamera.beta = azimuth.theta;
            }
        }
        ui.domInfo[0].innerHTML = ~~engine.getFps();
    });
    

    // -------------------------------------------------------
    // Scene


    function createScene(engine) {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
        scene.autoClear = false;
        scene.autoClearDepthAndStencil = false;
        scene.blockMaterialDirtyMechanism = true;
        scene.gravity = new BABYLON.Vector3(0, 0, 0);
        scene.collisionsEnabled = false;
        scene.useRightHandedSystem = true;

        camera.init(scene);

        const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
        ambient.diffuse = new BABYLON.Color3(0.8, 0.8, 0.8);
        ambient.specular = new BABYLON.Color3(0.8, 0.8, 0.8);
        ambient.groundColor = new BABYLON.Color3(0.4, 0.4, 0.4);
        ambient.intensity = 0.3; // overrided by setMode()

        const light = new BABYLON.DirectionalLight("direct", new BABYLON.Vector3(0, -1, 0), scene);
        setLightPositionByAngle(light, 120, 50, 100);
        light.autoUpdateExtends = true; // to REFRESHRATE_RENDER_ONCE
        light.diffuse = new BABYLON.Color3(0.8, 0.8, 0.8);
        light.intensity = 0.5;
        light.shadowMaxZ = 2500;
        light.shadowMinZ = -2500;

        // freezing shadows in static world
        // shadows updated manually on mesh changes to save performance
        const shadowGen = new BABYLON.ShadowGenerator(512, light);
        shadowGen.getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
        shadowGen.filteringQuality = BABYLON.ShadowGenerator.QUALITY_MEDIUM;
        shadowGen.useExponentialShadowMap = true; //def: true
        shadowGen.usePercentageCloserFiltering = true; // webgl2 only, fallback -> usePoissonSampling 
        shadowGen.forceBackFacesOnly = false;
        shadowGen.bias = 0.00005; //def: 0.00005 overrided by setMode()
        shadowGen.setDarkness(0.7); //overrided by setMode()
        
        const shadowcatcher = BABYLON.MeshBuilder.CreateGround("shadowcatcher", { width: 1000, height: 1000 }, scene);
        shadowcatcher.material = new BABYLON.ShadowOnlyMaterial('shadowcatcher', scene);
        shadowcatcher.material.shadowColor = BABYLON.Color3.FromHexString('#161a20');
        shadowcatcher.material.activeLight = light;
        shadowcatcher.material.backFaceCulling = true;
        shadowcatcher.material.alpha = 0.3;
        shadowcatcher.position.y = -0.5;
        shadowcatcher.receiveShadows = true;
        shadowcatcher.isPickable = false;
        shadowcatcher.doNotSyncBoundingInfo = true;
        shadowcatcher.doNotSerialize = true;
        shadowcatcher.convertToUnIndexedMesh();
        shadowcatcher.freezeWorldMatrix();
        shadowcatcher.freezeNormals();

        return scene;
    }

    function createAxisViewScene(engine) {
        const scene = new BABYLON.Scene(engine);
        scene.autoClear = false;
        scene.autoClearDepthAndStencil = true;
        scene.blockMaterialDirtyMechanism = true;
        scene.useRightHandedSystem = true;

        const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, -1, 0), scene);
        ambient.diffuse = new BABYLON.Color3(1, 1, 1);
        ambient.groundColor = new BABYLON.Color3(1, 1, 1);
        ambient.intensity = 1;

        const cam = new BABYLON.ArcRotateCamera("camera", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
        cam.viewport = updateViewport(100, 100, 5, -5);
        cam.radius = 5.2;
        cam.fov = 0.5;
        cam.alpha = engine.scenes[0].activeCamera.alpha;
        cam.beta = engine.scenes[0].activeCamera.beta;

        const cube = BABYLON.MeshBuilder.CreateBox("viewcube", { size: 0.45 }, scene);
        cube.material = new BABYLON.NormalMaterial("viewcube", scene);
        cube.material.backFaceCulling = true;
        cube.material.freeze();
        cube.doNotSyncBoundingInfo = true;
        cube.doNotSerialize = true;
        cube.convertToUnIndexedMesh();
        cube.freezeWorldMatrix();
        cube.freezeNormals();

        const axisHelper = new BABYLON.AxesViewer(scene, 0.5, 0, null,null,null, 4);
        axisHelper.xAxis.parent = cube;
        axisHelper.yAxis.parent = cube;
        axisHelper.zAxis.parent = cube;

        let axis = BABYLON.MeshBuilder.CreateSphere("viewaxes", { diameter: 0.45, segments: 5 }, scene);
        for (let i = 0; i < 6; i++) {
            const a = axis.clone();
            a.renderOverlay = true;
            a.renderOutline = true;
            a.outlineWidth = 0.04;
            a.overlayAlpha = 0.9;
            a.doNotSyncBoundingInfo = true;
            a.doNotSerialize = true;
            a.convertToUnIndexedMesh();
            a.freezeNormals();
            viewAxes.push(a);
        }
        axis.dispose();
        axis = null;

        viewAxes[0].position.x = 0.85;
        viewAxes[0].renderOutline = false;
        viewAxes[0].overlayColor = new BABYLON.Color3.FromHexString('#EA3751');
        viewAxes[1].position.x = -0.85;
        viewAxes[1].scaling.scaleInPlace(-0.9); // exclude border size
        viewAxes[1].overlayAlpha = 0.3;
        viewAxes[1].visibility = 0.01;
        viewAxes[1].overlayColor = viewAxes[0].overlayColor;
        viewAxes[1].outlineColor = viewAxes[0].overlayColor;
        viewAxes[2].position.y = 0.85;
        viewAxes[2].renderOutline = false;
        viewAxes[2].overlayColor = new BABYLON.Color3.FromHexString('#85D10C');
        viewAxes[3].position.y = -0.85;
        viewAxes[3].scaling.scaleInPlace(-0.9);
        viewAxes[3].overlayAlpha = 0.3;
        viewAxes[3].visibility = 0.01;
        viewAxes[3].overlayColor = viewAxes[2].overlayColor;
        viewAxes[3].outlineColor = viewAxes[2].overlayColor;
        viewAxes[4].position.z = 0.85;
        viewAxes[4].renderOutline = false;
        viewAxes[4].overlayColor = new BABYLON.Color3.FromHexString('#2F81DF');
        viewAxes[5].position.z = -0.85;
        viewAxes[5].scaling.scaleInPlace(-0.9);
        viewAxes[5].overlayAlpha = 0.3;
        viewAxes[5].visibility = 0.01;
        viewAxes[5].overlayColor = viewAxes[4].overlayColor;
        viewAxes[5].outlineColor = viewAxes[4].overlayColor;

        const predicate = function(mesh) {
            return viewAxes.includes(mesh) || mesh == cube;
        };

        scene.onPointerObservable.add((pInfo) => {
            if (pInfo.type == BABYLON.PointerEventTypes.POINTERDOWN) {
                const pick = scene.pick(scene.pointerX, scene.pointerY, predicate);
                if (pick.hit) {
                    if (pick.pickedMesh == cube) {
                        if (MODE == 1) { // solved picking conflict for camera.frame() (deselected bake)
                            bakery.selected = bakery.lastSelected;
                            bakery.lastSelected = null;
                        }
                        camera.frame();
                    } else {
                        if (MODE !== 2) {
                            if (pick.pickedMesh == viewAxes[0]) camera.setView('x');
                            if (pick.pickedMesh == viewAxes[1]) camera.setView('-x');
                            if (pick.pickedMesh == viewAxes[2]) camera.setView('y');
                            if (pick.pickedMesh == viewAxes[3]) camera.setView('-y');
                            if (pick.pickedMesh == viewAxes[4]) camera.setView('z');
                            if (pick.pickedMesh == viewAxes[5]) camera.setView('-z');
                        }
                    }
                }
            }
        });

        return scene;
    }


    // -------------------------------------------------------
    // Camera


    function Camera() {
        const CAM2SPEED = 0.9;
        this.camera0 = null;    // model (startup)
        this.camera1 = null;    // bake
        this.camera2 = null;    // render
        this.cameraView = '';
        let speedTimeout = null;
        
        this.init = function(scene) {
            this.camera0 = new BABYLON.ArcRotateCamera("camera_model", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
            this.camera1 = new BABYLON.ArcRotateCamera("camera_bakery", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
            this.camera2 = new BABYLON.UniversalCamera("camera_render", new BABYLON.Vector3(30, 35, 30), scene);

            const fov = parseFloat(document.getElementById('input-camera-fov').value); //def: 0.8

            this.camera0.setPosition(new BABYLON.Vector3(10, 10, 10));
            this.camera0.setTarget(BABYLON.Vector3.Zero());
            this.camera0.lowerRadiusLimit = 2;
            this.camera0.upperRadiusLimit = 1000;
            this.camera0.wheelPrecision = 8; //def: 3
            this.camera0.pinchPrecision = 40; //def: 12
            this.camera0.panningSensibility = 300; //def: 1000
            this.camera0.minZ = 1;
            this.camera0.maxZ = 1000;
            this.camera0.fov = fov; //def: 0.8

            this.camera1.setPosition(new BABYLON.Vector3(15, 15, 15));
            this.camera1.setTarget(BABYLON.Vector3.Zero());
            this.camera1.lowerRadiusLimit = 2;
            this.camera1.upperRadiusLimit = 1000;
            this.camera1.wheelPrecision = 8;
            this.camera1.pinchPrecision = 40;
            this.camera1.panningSensibility = 300;
            this.camera1.minZ = 1;
            this.camera1.maxZ = 1000;
            this.camera1.fov = fov;

            this.camera2.setTarget(BABYLON.Vector3.Zero());
            this.camera2.checkCollisions = false;
            this.camera2.applyGravity = false;
            this.camera2.speed = CAM2SPEED; // overrided
            this.camera2.minZ = 1;
            this.camera2.maxZ = 1000;
            this.camera2.inertia = 0.85;
            this.camera2.fov = fov;
            this.camera2.angularSensibility = 5000;
            this.camera2.ellipsoid = new BABYLON.Vector3(0.5, 0.5, 0.5);
            this.camera2._needMoveForGravity = false;
            this.camera2.keysUp = ['W'.charCodeAt(0)];
            this.camera2.keysLeft = ['A'.charCodeAt(0)];
            this.camera2.keysDown = ['S'.charCodeAt(0)];
            this.camera2.keysRight = ['D'.charCodeAt(0)];
            this.camera2.keysUpward = ['E'.charCodeAt(0)];
            this.camera2.keysDownward = ['Q'.charCodeAt(0)];
            this.camera2.onCollide = function(mesh) {
                //
            };
        }

        this.switchCamera = function() {
            scene.activeCamera.detachControl(canvas);
            if (MODE == 0) {
                scene.activeCamera = this.camera0;
                this.camera0.attachControl(canvas, true);
            } else if (MODE == 1) {
                scene.activeCamera = this.camera1;
                this.camera1.attachControl(canvas, true);
            } else if (MODE == 2) {
                scene.activeCamera = this.camera2;
                this.camera2.attachControl(canvas, true);
            }
            ui.domCamFov.value = scene.activeCamera.fov;
        }

        this.frame = function(scale = 45) {
            if (MODE == 0) {
                this.setFramingBehavior(this.camera0, builder.SPS.mesh, scale);
            } else if (MODE == 1) {
                if (bakery.selected) { // zoom to selected mesh
                    this.setFramingBehavior(this.camera1, bakery.selected, scale);
                } else {
                    animator(this.camera1, 'position', this.camera1.position.clone(), this.camera0.position, 10,10);
                    animator(this.camera1, 'target', this.camera1.target.clone(), this.camera0.target, 10,10);
                }
            } else if (MODE == 2) {
                if (bakery.meshes.length > 0) {
                    animator(this.camera2, 'position', this.camera2.position.clone(), this.camera1.position, 10,10);
                    animator(this.camera2, 'target', this.camera2.target.clone(), this.camera1.target, 10,10);
                } else { // frame to camera0 if there is no bake
                    animator(this.camera2, 'position', this.camera2.position.clone(), this.camera0.position, 10,10);
                    animator(this.camera2, 'target', this.camera2.target.clone(), this.camera0.target, 10,10);
                }
            }
            if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA)
                this.setOrthoZoom();
        }

        this.setFramingBehavior = function(cam, target, scale) {
            target.computeWorldMatrix(true);
            const bounds = target.getBoundingInfo();
            const bbox = bounds.boundingBox;
            const radiusWorld = bbox.maximumWorld.subtract(bbox.minimumWorld).scale(0.5);
            const centerWorld = bbox.minimumWorld.add(radiusWorld);
            const zoomTargetY = bbox.minimumWorld.y + (bbox.maximumWorld.y - bbox.minimumWorld.y) * 0.5;
            const zoomTarget = new BABYLON.Vector3(centerWorld.x, zoomTargetY, centerWorld.z);
            const radius = bounds.boundingSphere.radiusWorld;
            //cam.lowerRadiusLimit = radiusWorld.length() + cam.minZ;
            //cam.upperRadiusLimit = radiusWorld.length() + cam.maxZ;
            animator(cam, 'radius', cam.radius, radius + scale, 5,5);
            animator(cam, 'target', cam.target.clone(), zoomTarget, 5,5);
        }

        this.toggleCameraAutoRotation = function() {
            scene.activeCamera.useAutoRotationBehavior = !scene.activeCamera.useAutoRotationBehavior;
            if (scene.activeCamera.useAutoRotationBehavior) {
                scene.activeCamera.autoRotationBehavior.idleRotationSpeed = 0.1;
                scene.activeCamera.autoRotationBehavior.idleRotationWaitTime = 1;
                scene.activeCamera.autoRotationBehavior.idleRotationSpinupTime = 1;
            }
            ui.domAutoRotation.checked = scene.activeCamera.useAutoRotationBehavior;
        }

        this.switchOrtho = function() {
            if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {
                this.setView('persp');
            } else {
                this.setView('ortho');
            }
        }

        this.setView = function(name) {
            this.cameraView = name;
            builder.SPS.mesh.computeWorldMatrix(true);
            const bounds = builder.SPS.mesh.getBoundingInfo();
            const bbox = bounds.boundingBox;
            const zoomTargetY = bbox.minimumWorld.y + (bbox.maximumWorld.y - bbox.minimumWorld.y) * 0.5;
            const zoomTarget = new BABYLON.Vector3(0, zoomTargetY, 0);
            const radius = scene.activeCamera.radius;
            let position = null;
            
            switch (name) {
                case 'x':
                    position = new BABYLON.Vector3(1, 0, 0);
                    break;
                case '-x':
                    position = new BABYLON.Vector3(-1, 0, 0);
                    break;
                case 'y':
                    position = new BABYLON.Vector3(0, 1, 0);
                    break;
                case '-y':
                    position = new BABYLON.Vector3(0, -1, 0);
                    break;
                case 'z':
                    position = new BABYLON.Vector3(0, 0, 1);
                    break;
                case '-z':
                    position = new BABYLON.Vector3(0, 0, -1);
                    break;
                case 'persp':
                    scene.activeCamera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
                    ui.domOrthoBtn.innerHTML = 'Perspective';
                    break;
                case 'ortho':
                    scene.activeCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
                    ui.domOrthoBtn.innerHTML = 'Orthographic';
                    break;
            }

            this.setOrthoZoom();
            if (position) {
                position = position.multiplyByFloats(radius, radius, radius).add(zoomTarget);
                scene.activeCamera.position = position;
            }
            scene.activeCamera.target = zoomTarget;
        }

        this.setOrthoZoom = function() { // TODO: 2!
            scene.activeCamera.orthoTop = (scene.activeCamera.radius / 2);
            scene.activeCamera.orthoBottom = -(scene.activeCamera.radius / 2);
            scene.activeCamera.orthoLeft = -(scene.activeCamera.radius / 2) * scene.getEngine().getAspectRatio(scene.activeCamera);
            scene.activeCamera.orthoRight = (scene.activeCamera.radius / 2) * scene.getEngine().getAspectRatio(scene.activeCamera);
        }

        this.setFov = function(elem) {
            const fov = parseFloat(elem.value);
            scene.activeCamera.fov = fov;
            if (MODE == 2) {
                ui.domReticle.children[2].style.width = fov * 100 + 'px';
                ui.domReticle.children[2].style.height = fov * 100 + 'px';
                ui.domReticle.children[2].style.marginLeft = 49-(fov * 100)/2 + 'px';
                ui.domReticle.children[2].style.marginTop = 49-(fov * 100)/2 + 'px';
            }
            ui.updateStatus();
        }

        this.speedUp = function() {
            if (this.camera2.speed == CAM2SPEED)
                clearTimeout(speedTimeout);

            this.camera2.speed = CAM2SPEED * 3;
            speedTimeout = setTimeout(() => {
                this.camera2.speed = CAM2SPEED;
            }, 2000);
        }
    }


    // -------------------------------------------------------
    // HDRI and Skybox


    function HDRI(scene) {
        this.hdrMap = null;
        this.skybox = null;
        this.isLoaded = false;

        this.initHDRI = async () => { await this.init() }

        this.init = async function() {
            this.hdrMap = new BABYLON.HDRCubeTexture(texenv, scene, 512, undefined,undefined,undefined,undefined, () => {
                hdri.hdrMap.gammaSpace = false;
                hdri.skybox = hdri.createSkybox(hdri.hdrMap.clone(), parseFloat(ui.domHdriBlur.value));
                scene.environmentTexture = hdri.hdrMap;
            });
        }

        this.loadHDR = function(url) {
            if (url == '') return;
            if (this.hdrMap) {
                this.hdrMap.dispose();
                this.hdrMap = null;
            }
            this.hdrMap = new BABYLON.HDRCubeTexture(url, scene, 512, undefined,undefined,undefined,undefined, () => {
                hdri.hdrMap.gammaSpace = false;
                if (hdri.skybox.material.reflectionTexture)
                    hdri.skybox.material.reflectionTexture.dispose();
                hdri.skybox.material.reflectionTexture = hdri.hdrMap.clone();
                hdri.skybox.material.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
                hdri.skybox.isVisible = ui.domHdriToggle.checked;
                scene.environmentTexture = hdri.hdrMap;
                
                bakery.updateReflectionTextures();

                hdri.isLoaded = true;
                ui.updateStatus();
            });
        }

        this.unloadHDR = function() {
            this.loadHDR(texenv);
        }

        this.createSkybox = function(tex, blur) {
            const dist = (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2;
            const skybox = BABYLON.MeshBuilder.CreateBox('skybox', { size: dist }, scene);
            skybox.material = new BABYLON.PBRMaterial("skybox", scene);
            skybox.material.reflectionTexture = tex;
            skybox.material.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skybox.material.microSurface = 1.0 - blur;
            skybox.material.disableLighting = true;
            skybox.material.twoSidedLighting = true;
            skybox.material.backFaceCulling = false;
            skybox.isPickable = false;
            skybox.isVisible = false;
            skybox.infiniteDistance = true;
            skybox.ignoreCameraMaxZ = true;
            skybox.doNotSyncBoundingInfo = true;
            skybox.convertToUnIndexedMesh();
            skybox.freezeWorldMatrix();
            skybox.freezeNormals();
            return skybox;
        }

        this.toggleSkybox = function(isShow) {
            if (this.skybox)
                this.skybox.isVisible = isShow;
            ui.updateStatus();
        }

        this.setBlurAmount = function(num) {
            this.skybox.material.microSurface = 1.0 - num;
        }

        this.init();
    }


    // -------------------------------------------------------
    // Pipeline (post-process)


    function Pipeline(scene) {
        this.pip = null;
        this.ssao = null;
        this.isHq = false;
        this.curve = null;

        this.init = function() {
            if (this.pip) this.dispose(); // prevent overdraw

            this.pip = new BABYLON.DefaultRenderingPipeline("default", true, scene,
                [ camera.camera2 ]);

            this.pip.imageProcessingEnabled = true;
            this.pip.imageProcessing.toneMappingEnabled = true;
            this.pip.imageProcessing.applyByPostProcess = true;
            this.pip.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
            this.pip.imageProcessing.contrast = parseFloat(ui.domPipelineContrast.value);
            this.pip.imageProcessing.exposure = parseFloat(ui.domPipelineExposure.value);
            //this.pip.imageProcessing.vignetteEnabled = false;
            //this.pip.imageProcessing.vignetteWeight = 1;
            //this.pip.imageProcessing.vignetteStretch = 2;
            //this.pip.imageProcessing.vignetteColor = new BABYLON.Color4(0, 0, 0, 0);
            this.pip.imageProcessing.colorCurvesEnabled = true;
            if (this.pip.imageProcessing.colorCurvesEnabled) {
                this.curve = new BABYLON.ColorCurves();
                this.curve.globalDensity = 0; //def: 0
                this.curve.globalExposure = 0; //def: 0
                this.curve.globalHue = parseInt(ui.domPipelineHue.value); //def: 30
                this.curve.globalSaturation = 0; //def: 0
                this.curve.highlightsDensity = 0; //def: 0
                this.curve.highlightsExposure = 0; //def: 0
                this.curve.highlightsHue = parseInt(ui.domPipelineHue.value); //def: 30
                this.curve.highlightsSaturation = 0; //def: 0
                this.curve.midtonesDensity = 0; //def: 0
                this.curve.midtonesExposure = 0; //def: 0
                this.curve.midtonesHue = parseInt(ui.domPipelineHue.value); //def: 30
                this.curve.midtonesSaturation = 0; //def: 0
                this.curve.shadowsDensity = 0; //def: 0
                this.curve.shadowsExposure = 0; //def: 0
                this.curve.shadowsHue = parseInt(ui.domPipelineHue.value); //def: 30
                this.curve.shadowsDensity = 80; // def: 80
                this.curve.shadowsSaturation = 0; //def: 0
                this.pip.imageProcessing.colorCurves = this.curve;
            }

            this.pip.samples = 1; //MSAA def: 1
            this.pip.fxaaEnabled = true;
            if (this.pip.fxaaEnabled)
                this.pip.fxaa.samples = 1; //def: 1

            this.pip.sharpenEnabled = true;
            this.pip.sharpen.edgeAmount = parseFloat(ui.domPipelineSharpen.value);
            this.pip.sharpen.colorAmount = 1;

            this.pip.grainEnabled = true;
            this.pip.grain.intensity = 5;
            this.pip.grain.animated = true;

            this.pip.bloomEnabled = ui.domPipelineBloom.checked;
            if (this.pip.bloomEnabled) {
                this.pip.bloomThreshold = 0.4;
                this.pip.bloomWeight = 0.3;
                this.pip.bloomKernel = 64;
                this.pip.bloomScale = 0.5;
            }

            this.pip.depthOfFieldEnabled = ui.domPipelineDof.checked;
            if (this.pip.depthOfFieldEnabled) {
                this.pip.depthOfField.focusDistance = parseInt(ui.domPipelineDofDist.value) * builder.SPS.mesh.getDistanceToCamera(camera.camera2);
                this.pip.depthOfField.focalLength = 180;
                this.pip.depthOfField.fStop = 2.0;
                this.pip.depthOfField.lensSize = 50; // default
                this.pip.depthOfFieldBlurLevel = BABYLON.DepthOfFieldEffectBlurLevel.Medium;
                if (isMobileDevice())
                    this.pip.depthOfFieldBlurLevel = BABYLON.DepthOfFieldEffectBlurLevel.Low;
            }

            this.pip.chromaticAberrationEnabled = true;
            if (this.pip.chromaticAberrationEnabled) {
                this.pip.chromaticAberration.aberrationAmount = parseInt(ui.domPipelineChromatic.value); //def: 30
                this.pip.chromaticAberration.alphaMode = 0; //def: 0
                this.pip.chromaticAberration.alwaysForcePOT = false; //def: false
                this.pip.chromaticAberration.enablePixelPerfectMode = false; //def: false
                this.pip.chromaticAberration.forceFullscreenViewport = true;
            }
            
            if (!isMobileDevice()) {
                this.ssao = new BABYLON.SSAORenderingPipeline("ssao", scene,
                    { ssaoRatio: 0.5, combineRatio: 1.0 }, [ camera.camera2 ]);
                this.ssao.fallOff = 0.00001;  //def: 0.000001
                this.ssao.radius = 0.0010;    //def: 0.0006
                this.ssao.area = 0.0100;      //def: 0.0075
                this.ssao.base = 0.6;         //lower=darker
                this.ssao.totalStrength = 1;
            }

            this.isHq = true;
            ui.domPipelineDofDist.disabled = !ui.domPipelineDof.checked;
        }

        this.updateProps = function() {
            if (MODE == 2 && this.pip) {
                this.pip.imageProcessing.contrast = parseFloat(ui.domPipelineContrast.value);
                this.pip.imageProcessing.exposure = parseFloat(ui.domPipelineExposure.value);
                this.pip.bloomEnabled = ui.domPipelineBloom.checked;
                this.pip.depthOfFieldEnabled = ui.domPipelineDof.checked;
                this.pip.depthOfField.focusDistance = parseInt(ui.domPipelineDofDist.value) * builder.SPS.mesh.getDistanceToCamera(camera.camera2);
                this.pip.sharpen.edgeAmount = parseFloat(ui.domPipelineSharpen.value);
                this.pip.chromaticAberration.aberrationAmount = parseInt(ui.domPipelineChromatic.value);
                this.curve.globalHue = parseInt(ui.domPipelineHue.value);
                this.curve.highlightsHue = parseInt(ui.domPipelineHue.value);
                this.curve.midtonesHue = parseInt(ui.domPipelineHue.value);
                this.curve.shadowsHue = parseInt(ui.domPipelineHue.value);
            }
        }

        this.toggle = function() {
            if (this.isHq) {
                this.dispose();
            } else {
                this.init();
            }
        }

        this.dispose = function() {
            if (this.ssao) {
                this.ssao.dispose();
                this.ssao = null;
            }
            if (this.pip) { // important to prevent multiple camera conflict
                this.pip.fxaaEnabled = false;
                this.pip.imageProcessingEnabled = false;
                this.pip.sharpenEnabled = false;
                this.pip.grainEnabled = false;
                this.pip.bloomEnabled = false;
                this.pip.depthOfFieldEnabled = false;
                this.pip.chromaticAberrationEnabled = false;
                this.pip.dispose();
                this.pip = null;
            }
            this.isHq = false;
        }
    }

    
    // -------------------------------------------------------
    // Material


    function Material(scene) {
        this.texId = 0;    // current PBR texture
        this.mat_cel = null;
        this.mat_pbr = null;
        this.mat_ghost = null;
        this.mat_workplane = null;
        this.mat_grid = null;
        this.tex_cel = null;
        this.tex_pbr = null;
        this.textures = [];
        let numDefTex = 0;
        let isShowGrid = true;

        this.init = function() {
            this.textures[0] = this.createTexture('texpat0', texpat0); // patterns
            this.textures[1] = this.createTexture('texpat1', texpat1, BABYLON.Texture.LINEAR_LINEAR_MIPLINEAR);
            this.textures[2] = this.createTexture('texpat2', texpat2, BABYLON.Texture.LINEAR_LINEAR_MIPLINEAR);
            this.textures[3] = this.createTexture('texpat3', texpat3, BABYLON.Texture.LINEAR_LINEAR_MIPLINEAR);
            numDefTex = this.textures.length;

            this.addTexture(tex0); // import samples
            this.addTexture(tex1);
            this.addTexture(tex2);
            this.addTexture(tex3);
            this.addTexture(tex4);

            this.tex_cel = this.createVoxelTexture('#000000');
            this.setPBRTexture(); //def: 1

            this.createCelMaterial();
            this.createWorkplaneMaterial();
            this.createGridMaterial();
            this.createGhostMaterial();
        }

        this.update = function() {
            this.createPBRMaterial();
        }

        this.createCelMaterial = function() {
            if (this.mat_cel) {
                this.mat_cel.dispose();
                this.mat_cel = null;
            }
            const mat = new BABYLON.StandardMaterial("CEL", scene);
            mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            mat.specularColor = new BABYLON.Color3(0, 0, 0);
            mat.emissiveColor = new BABYLON.Color3(0.25, 0.25, 0.25);
            mat.emissiveTexture = this.tex_cel;
            mat.opacityTexture = this.tex_cel;
            mat.opacityFresnelParameters = new BABYLON.FresnelParameters();
            mat.opacityFresnelParameters.leftColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            mat.opacityFresnelParameters.rightColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            mat.useEmissiveAsIllumination = false;
            mat.linkEmissiveWithDiffuse = true;
            mat.backFaceCulling = true;
            mat.transparencyMode = 0;
            mat.freeze();
            this.mat_cel = mat;
        }

        this.createPBRMaterial = function() { // initial/overrided
            if (this.mat_pbr) {
                this.mat_pbr.albedoTexture.dispose();
                this.mat_pbr.reflectionTexture.dispose();
                this.mat_pbr.dispose();
                this.mat_pbr = null;
            }
            const mat = new BABYLON.PBRMaterial("PBR", scene);
            mat.albedoColor = new BABYLON.Color3(1, 1, 1);
            mat.albedoTexture = this.tex_pbr.clone();
            mat.reflectionTexture = hdri.hdrMap.clone();
            mat.reflectionTexture.coordinatesMode = BABYLON.Texture.CUBIC_MODE;
            mat.roughness = 0.8;
            mat.metallic = 0.2;
            mat.alpha = 1;
            mat.alphaCutOff = 0.5;
            mat.alphaMode = BABYLON.PBRMaterial.PBRMATERIAL_ALPHABLEND;
            mat.transparencyMode = 1;
            mat.useAlphaFromAlbedoTexture = true;
            mat.backFaceCulling = true;
            mat.specularIntensity = 1;
            mat.directIntensity = 1;
            mat.environmentIntensity = 1;
            this.mat_pbr = mat;
        }

        this.createExportMaterial = function() {
            const mat = new BABYLON.StandardMaterial("export", scene);
            mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            mat.specularColor = new BABYLON.Color3(1, 1, 1);
            mat.backFaceCulling = true;
            mat.freeze();
            return mat;
        }

        this.createWorkplaneMaterial = function() {
            const mat = new BABYLON.GridMaterial("workplane", scene);
            mat.gridRatio = 1;
            mat.majorUnitFrequency = 20;
            mat.minorUnitVisibility = 0.3;
            mat.mainColor = new BABYLON.Color3(0, 1, 1);
            mat.lineColor = new BABYLON.Color3(0, 1, 1);
            mat.opacity = 0.5;
            mat.backFaceCulling = false;
            mat.freeze();
            this.mat_workplane = mat;
        }
    
        this.createGridMaterial = function() {
            const mat = new BABYLON.GridMaterial("grid", scene);
            mat.opacityTexture = new BABYLON.Texture(PARTICLE, scene, undefined, undefined, BABYLON.Texture.NEAREST_SAMPLINGMODE);
            mat.opacityTexture.optimizeUVAllocation = true;
            mat.gridRatio = 0; // overrided by setGrid()
            mat.majorUnitFrequency = 40;
            mat.minorUnitVisibility = 0.3;
            mat.mainColor = new BABYLON.Color3(1,1,1);
            mat.lineColor = new BABYLON.Color3(1,1,1);
            mat.opacity = 0.05;
            mat.backFaceCulling = false;
            mat.freeze();
            this.mat_grid = mat;
        }

        this.createGhostMaterial = function() {
            const mat = new BABYLON.StandardMaterial("ghostvoxel", scene);
            mat.diffuseColor = new BABYLON.Color3(0, 0, 0); // overrided
            mat.specularColor = new BABYLON.Color3(0, 0, 0);
            mat.emissiveColor = new BABYLON.Color3(0.25, 0.25, 0.25);
            mat.emissiveTexture = this.tex_cel;
            mat.opacityTexture = this.tex_cel;
            mat.opacityFresnelParameters = new BABYLON.FresnelParameters();
            mat.opacityFresnelParameters.leftColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            mat.opacityFresnelParameters.rightColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            mat.useEmissiveAsIllumination = false;
            mat.linkEmissiveWithDiffuse = true;
            mat.backFaceCulling = true;
            mat.transparencyMode = 0;
            mat.checkReadyOnEveryCall = false;
            this.mat_ghost = mat;
        }

        this.createVoxelTexture = function(hex) {
            const tex = new BABYLON.DynamicTexture('voxelgrid', 256, scene, BABYLON.Texture.NEAREST_SAMPLINGMODE);
            const ctx = tex.getContext();
            ctx.lineWidth = 4; // grid
            ctx.strokeStyle = hex + '20';
            ctx.beginPath();
            ctx.moveTo(0, 128);
            ctx.lineTo(256, 128);
            ctx.moveTo(128, 0);
            ctx.lineTo(128, 256);
            ctx.stroke();
            ctx.lineWidth = 8; // outline
            ctx.strokeStyle = hex + '60';
            ctx.strokeRect(0, 0, 256, 256);
            tex.update();
            tex.hasAlpha = true;
            tex.getAlphaFromRGB = false;
            return tex;
        }

        this.createTexture = function(name, url, sampling = BABYLON.Texture.NEAREST_SAMPLINGMODE) {
            const tex = new BABYLON.Texture(url, scene, undefined, undefined, sampling);
            tex.name = name;
            tex.uScale = 1;
            tex.vScale = 1;
            tex.hasAlpha = true;
            tex.gammaSpace = true;
            tex.optimizeUVAllocation = true;
            return tex;
        }

        this.setPBRTexture = function(idx = 1) {
            this.texId = idx;
            this.tex_pbr = this.textures[idx];
        }

        this.addTexture = function(data) {
            this.textures.push(this.createTexture('texpbr_user', data));
            const idx = this.textures.length - 1;
            this.setPBRTexture(idx);
            this.update();
            const li = document.createElement("li");
            li.classList.add("img");
            li.innerHTML = `<img src="${ data }">`;
            li.addEventListener("click", () => {
                for (let i of ui.domTexturePresets.children)  // unselect
                    i.firstChild.style.borderColor = '#6b798d'; // presets
                li.firstChild.style.borderColor = COL_ORANGE; // select preset

                material.setPBRTexture(idx);
                bakery.replaceTexture();
            }, false);
            ui.domTexturePresets.appendChild(li);
        }

        this.deleteTexture = function(evt) {
            evt.preventDefault();
            let data = evt.dataTransfer.getData("text");
            const imgs = document.querySelectorAll('#menu-texture img');
            for (let i = 0; i < imgs.length; i++) {
                if (imgs[i].src == data) {
                    imgs[i].src = '';
                    if (i > numDefTex)
                        this.textures[i].dispose();
                    ui.domTexturePresets.removeChild(imgs[i].parentElement);
                }
            }
            data = null;
            this.setPBRTexture();
            this.update();
        }

        this.init();
    }


    // -------------------------------------------------------
    // Builder (SPS particles)
    // voxel = {
    //    position: vector3,
    //    color: #HEXHEX (uppercase/no alpha)
    //    visible: bool
    // }


    function Builder(scene) {
        this.voxels = [];
        this.voxel = null;
        this.SPS = null;
        this.isOnionSkin = false;

        this.init = function() {
            this.voxel = BABYLON.MeshBuilder.CreateBox("voxel", { sideOrientation: BABYLON.Mesh.FRONTSIDE, updatable: false }, scene);
            this.voxel.isVisible = false;
            this.voxel.isPickable = false;
            this.voxel.doNotSerialize = true;
            this.voxel.convertToUnIndexedMesh();
            this.voxel.freezeNormals();
            this.voxel.freezeWorldMatrix();
        }

        this.createSPS = function(voxels = this.voxels) {
            if (this.SPS) {
                this.SPS.dispose();
                this.SPS = null;
            }
            this.SPS = new BABYLON.SolidParticleSystem('SPS', scene, { 
                isPickable: true, updatable: true, expandable: false,
                boundingSphereOnly: true // faster, no bbox computation
            });
            
            this.SPS.addShape(this.voxel, voxels.length, { positionFunction: (particle, i, s) => {
                particle.position.copyFrom(voxels[i].position);
                particle.color = BABYLON.Color4.FromHexString(voxels[i].color);
            }});

            const mesh = this.SPS.buildMesh();
            mesh.material = material.mat_cel;
            mesh.receiveShadows = true;
            scene.lights[1].getShadowGenerator().addShadowCaster(mesh);
            mesh.freezeWorldMatrix();
            mesh.freezeNormals();

            this.SPS.initParticles = () => {
                for (let i = 0; i < this.SPS.nbParticles; i++) {  // respect hidden voxels, to enable new feature:
                    this.SPS.particles[i].isVisible = voxels[i].visible; // hide voxels
                }
            }

            this.SPS.initParticles();
            this.SPS.setParticles();       // update SPS mesh and draw it
            this.SPS.refreshVisibleSize(); // update BBox for picking and shadows
            this.SPS.computeBoundingBox = false;
            this.SPS.computeParticleColor = false;
            this.SPS.computeParticleRotation = false;
            this.SPS.computeParticleTexture = false;
            this.SPS.computeParticleVertex = false;

            this.setOnionSkin();
            helper.setGrid(mesh);
            ui.updateStatus();
            updateShadowMap();
        }

        this.add = function(pos, hex, visible) {
            this.voxels.push({ position: pos, color: hex, visible: visible });
        }

        this.addNoDup = function(pos, hex, visible) {
            if (this.findIndexByPosition(pos) == -1) // no duplicates allowed
                this.voxels.push({ position: pos, color: hex, visible: visible });
        }

        this.remove = function(index) {
            if (builder.voxels.length > 1) { // 1 voxel minimum, useless but keep it
                index = this.voxels.indexOf(this.voxels[index]);
                if (index > -1)
                    this.voxels.splice(index, 1);
            }
        }

        this.removeByPosition = function(pos) {
            this.remove(this.findIndexByPosition(pos));
        }

        this.removeDuplicates = function() {
            const last = this.voxels.length;
            this.voxels = this.voxels.filter((value, index, self) =>
                index === self.findIndex(i =>
                    i.position.x == value.position.x &&
                    i.position.y == value.position.y &&
                    i.position.z == value.position.z
                ));
            return last - this.voxels.length;
        }

        this.removeDuplicatesFunc = function() {
            engine.displayLoadingUI();
            setTimeout(() => {
                const count = this.removeDuplicates();
                ui.notification(`found ${ count } duplicates`);
                engine.hideLoadingUI();
            }, 0);
        }

        this.findIndexByPosition = function(pos) {
            return this.voxels.findIndex(i =>
                i.position.x == pos.x &&
                i.position.y == pos.y &&
                i.position.z == pos.z);
        }

        this.findIndexByColor = function(hex) {
            return this.voxels.findIndex(i => i.color == hex);
        }

        this.getVoxelsByPosition = function(pos) {
            return this.voxels.filter(i =>
                i.position.x == pos.x &&
                i.position.y == pos.y &&
                i.position.z == pos.z);
        }

        this.getVoxelsByColor = function(hex) {
            return this.voxels.filter(i => i.color == hex);
        }

        this.getVoxelsByVisibility = function(isVisible) {
            return this.voxels.filter(i => i.visible == isVisible);
        }

        this.setVoxelPosition = function(index, pos) {
            this.voxels[index].position = pos;
            this.SPS.particles[index].position = pos;
        }

        this.setVoxelColor = function(index, hex) {
            this.voxels[index].color = hex;
        }

        this.setVoxelVisible = function(index, visible) {
            this.voxels[index].visible = visible;
            this.SPS.particles[index].isVisible = visible;
        }

        this.deleteHidden = function() {
            if (this.getVoxelsByVisibility(true).length == 0) {
                ui.notification('unable to find visible voxels');
                return;
            }
            const len = this.voxels.length;
            let voxels = this.getVoxelsByVisibility(false);
            for (let i = 0; i < voxels.length; i++) {
                this.voxels.splice(this.voxels.indexOf(voxels[i]), 1);
            }
            voxels = null;
            this.createSPS();
            palette.create();
            if (this.voxels.length !== len)
                memory.record(); // record on changes
        }

        this.invertVisibility = function() {
            if (this.getVoxelsByVisibility(false).length == 0) {
                ui.notification('nothing to invert');
                return;
            }
            for (let i = 0; i < this.voxels.length; i++) {
                this.setVoxelVisible(i, !this.voxels[i].visible);
            }
            this.SPS.setParticles();
            palette.create();
            updateShadowMap();
        }

        this.setVoxelsVisibility = function(isVisible) {
            for (let i = 0; i < this.voxels.length; i++)
                this.setVoxelVisible(i, isVisible);
            this.createSPS();
            palette.create();
            helper.setGrid(this.SPS.mesh);
            updateShadowMap();
        }

        this.setMeshVisibility = function(isVisible) {
            this.SPS.mesh.isVisible = isVisible;
        }

        this.setOnionSkin = function() {
            if (this.isOnionSkin) {
                this.SPS.mesh.visibility = 0.5;
            } else {
                this.SPS.mesh.visibility = 1;
            }
        }

        this.toggleOnionSkin = function() {
            this.isOnionSkin = !this.isOnionSkin; 
            this.setOnionSkin();
        }

        this.normalizeVoxelPositions = function(isRecordMem) {
            const bounds = this.SPS.mesh.getBoundingInfo();
            const size = getMeshSize(bounds);
            const center = bounds.boundingBox.center;
            const nX = -bounds.maximum.x + (size.x / 2);
            const nY = ((size.y / 2) - center.y) - 0.5;
            const nZ = -bounds.maximum.z + (size.z / 2);
            let transMatrix = null;
            let position = null;
            for (let i = 0; i < this.voxels.length; i++) {
                transMatrix = BABYLON.Matrix.Translation(nX, nY, nZ);
                position = BABYLON.Vector3.TransformCoordinates(this.voxels[i].position, transMatrix);
                this.setVoxelPosition(i, position);
            }
            this.SPS.setParticles();
            this.SPS.refreshVisibleSize();
            transMatrix = null;
            position = null;
            if (isRecordMem) {
                if (!this.SPS.mesh.getBoundingInfo().boundingBox.center.equals(center))
                    memory.record(); // record on changes

                helper.setGrid(this.SPS.mesh);
                ui.notification('normalized');
            }
            updateShadowMap();
        }

        this.reduceVoxels = async function() {
            if (!await ui.showConfirm('This operation is not undoable<br>continue?')) return;
            engine.displayLoadingUI();
            setTimeout(() => {
                let reduced = this.voxels.length;
                let toDelete = [];
                let idx = []; // remove voxels by testing 6 sides
                let test = [
                    new BABYLON.Vector3(1, 0, 0),
                    new BABYLON.Vector3(-1, 0, 0),
                    new BABYLON.Vector3(0, 1, 0),
                    new BABYLON.Vector3(0, -1, 0),
                    new BABYLON.Vector3(0, 0, 1),
                    new BABYLON.Vector3(0, 0, -1)
                ];
                for (let i = 0; i < this.voxels.length; i++) {
                    idx[0] = this.findIndexByPosition(this.voxels[i].position.add(test[0]));
                    idx[1] = this.findIndexByPosition(this.voxels[i].position.add(test[1]));
                    idx[2] = this.findIndexByPosition(this.voxels[i].position.add(test[2]));
                    idx[3] = this.findIndexByPosition(this.voxels[i].position.add(test[3]));
                    idx[4] = this.findIndexByPosition(this.voxels[i].position.add(test[4]));
                    idx[5] = this.findIndexByPosition(this.voxels[i].position.add(test[5]));
                    if (idx[0] > -1 && idx[1] > -1 && idx[2] > -1 && idx[3] > -1 && idx[4] > -1 && idx[5] > -1)
                        toDelete.push(this.voxels[i]);
                }
                for (let i = 0; i < toDelete.length; i++) {
                    this.voxels.splice(this.voxels.indexOf(toDelete[i]), 1);
                }
                this.createSPS();
                palette.create();
                ui.notification(`${ reduced - this.voxels.length } voxels removed`);
                idx = null;
                test = null;
                toDelete = null;
                engine.hideLoadingUI();
            }, 0);
        }

        this.getData = function() { // raw io, used in Memory and Storage
            let data = '';
            for (let i = 0; i < this.voxels.length; i++) {
                data += this.voxels[i].position.x + ',' +
                        this.voxels[i].position.y + ',' +
                        this.voxels[i].position.z + ',' +
                        this.voxels[i].color + ',' +
                        this.voxels[i].visible + ';';
            }
            return data;
        }

        this.setData = function(data) {
            let newData = [];
            let voxels = data.split(';').slice(0, -1);
            for (let i = 0; i < voxels.length; i++) {
                const chunk = voxels[i].split(',');
                newData.push({ 
                    position: new BABYLON.Vector3(
                        parseFloat(chunk[0]),
                        parseFloat(chunk[1]),
                        parseFloat(chunk[2])
                    ),
                    color: chunk[3],
                    visible: parseBool(chunk[4])
                });
            }
            this.voxels = newData;
            this.createSPS();
            palette.create();
            // reset toggles
            data = null;
            newData = null;
        }

        // used in file, project and generator functions
        // except memory record, do after createSPS()
        // except symmetry axis, do after createSPS()
        this.loadData = function(data, isDupCheck = true, isNormalize = false) {
            this.voxels = []; // important
            for (let i = 0; i < data.length; i++) 
                this.add(data[i].position, data[i].color, data[i].visible);
            if (isDupCheck)
                this.removeDuplicates();
            this.createSPS();
            palette.create();
            if (isNormalize)
                this.normalizeVoxelPositions(false);
            if (helper.workPlane.isVisible) {
                helper.workPlane.isVisible = false;
                helper.resetWorkplane(BABYLON.Axis.X);
                helper.resetWorkplane(BABYLON.Axis.Z);
                helper.resetWorkplane(BABYLON.Axis.Y); // important
                uix.unbindWorkplane();
            }
            ui.updateStatus();
            data = null;
        }

        this.init();
    }


    // -------------------------------------------------------
    // Palette (color palette)


    function Palette() {
        const size = 20;
        let ctx = null;
        this.uniqueColors = [];

        this.init = function() {
            ctx = canvasP.getContext('2d', { willReadFrequently: true });
            
            canvasP.addEventListener("pointerdown", function(ev) {
                const hex = getCanvasColor(ctx, ev.offsetX, ev.offsetY);
                if (palette.uniqueColors.includes(hex)) {
                    currentColor = hex;
                    uix.colorPicker.value = BABYLON.Color3.FromHexString(hex);
                }
            }, false);

            canvasP.addEventListener("dblclick", function(ev) {
                const hex = getCanvasColor(ctx, ev.offsetX, ev.offsetY);
                if (palette.uniqueColors.includes(hex)) {
                    if (palette.isColorVisible(hex)) {
                        palette.setColorVisible(hex, false);
                    } else {
                        palette.setColorVisible(hex, true);
                    }
                }
            }, false);
        }

        this.create = function() {   // generate color palette
            canvasP.width = canvasP.clientWidth;
            canvasP.height = canvasP.clientHeight;
            ctx.clearRect(0, 0, canvasP.width, canvasP.height);

            let padding = 2;
            this.uniqueColors = [];
            for (let i = 0; i < builder.voxels.length; i++) {
                if (this.uniqueColors.indexOf(builder.voxels[i].color) == -1) {
                    this.addColor(padding, builder.voxels[i].color);
                    this.uniqueColors.push(builder.voxels[i].color);
                    padding += size + 2;
                }
            }
        }
        
        this.addColor = function(pad, hex) {
            if (this.isColorVisible(hex)) { // respect the stored visibility state
                ctx.strokeStyle = 'transparent';
            } else {
                ctx.strokeStyle = 'orange';
            }
            ctx.lineWidth = 2;
            ctx.strokeRect(1, pad, 30, size);
            ctx.fillStyle = hex;
            ctx.fillRect(1, pad, 30, size);
        }

        this.setColorVisible = function(hex, isVisible) {
            let voxels = builder.getVoxelsByColor(hex);
            for (let i = 0; i < voxels.length; i++)
                voxels[i].visible = isVisible;
            builder.createSPS();
            this.create();
            voxels = null;
        }

        this.isColorVisible = function(hex) {
            const idx = builder.findIndexByColor(hex);
            if (idx > -1)
                return builder.voxels[ idx ].visible;
            return false;
        }

        this.init();
    }
    

    // -------------------------------------------------------
    // Helper (overlays)


    function Helper(scene, sceneAxisView) {
        this.gridPlane = BABYLON.MeshBuilder.CreatePlane("gridplane", { width: 3, height: 3, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, scene);
        this.workPlane = BABYLON.MeshBuilder.CreatePlane("workplane", { size: 1000, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, scene);
        this.axisPlane = BABYLON.MeshBuilder.CreatePlane("axisplane", { width: 1.05, height: 1.05, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, sceneAxisView);
        this.overlayPlane = BABYLON.MeshBuilder.CreatePlane("overlayplane", { sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, scene);
        this.overlayCube = BABYLON.MeshBuilder.CreateBox("overlaycube", { size: 1, sideOrientation: BABYLON.Mesh.FRONTSIDE, updatable: false }, scene);
        this.ghostBox = BABYLON.MeshBuilder.CreateBox("ghostbox", { size: 1, sideOrientation: BABYLON.Mesh.FRONTSIDE, updatable: false }, scene);
        this.ghostVoxel = null;
        this.workplaneAxis = BABYLON.Axis.Y;

        this.init = function() {
            this.gridPlane.material = material.mat_grid;
            this.gridPlane.isVisible = true;
            this.gridPlane.isPickable = false;
            this.gridPlane.position.y = -0.5;
            this.gridPlane.rotation.x = PIH;
            this.gridPlane.doNotSerialize = true;
            this.gridPlane.convertToUnIndexedMesh();
            this.gridPlane.freezeNormals();
            this.axisPlane.isVisible = false; // indicate symmetry-axis plane in AxisView scene
            this.axisPlane.isPickable = false;
            this.axisPlane.visibility = 0.3;
            this.axisPlane.renderOverlay = true;
            this.axisPlane.overlayAlpha = 0.5;
            this.axisPlane.overlayColor = BABYLON.Color3.FromHexString('#FF00FF');
            this.axisPlane.edgesWidth = 8;
            this.axisPlane.edgesColor = BABYLON.Color4.FromHexString('#FF00FFFF');
            this.axisPlane.doNotSerialize = true;
            this.axisPlane.enableEdgesRendering();
            this.axisPlane.convertToUnIndexedMesh();
            this.axisPlane.freezeNormals();
            this.overlayPlane.isVisible = false;
            this.overlayPlane.isPickable = false;
            this.overlayPlane.visibility = 0.1;
            this.overlayPlane.renderOverlay = true;
            this.overlayPlane.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
            this.overlayPlane.overlayAlpha = 0.5;
            this.overlayPlane.edgesWidth = 6;
            this.overlayPlane.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
            this.overlayPlane.doNotSerialize = true;
            this.overlayPlane.enableEdgesRendering();
            this.overlayPlane.convertToUnIndexedMesh();
            this.overlayPlane.freezeNormals();
            this.overlayCube.isVisible = false;
            this.overlayCube.isPickable = false;
            this.overlayCube.visibility = 0.1;
            this.overlayCube.renderOverlay = true;
            this.overlayCube.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
            this.overlayCube.overlayAlpha = 0.5;
            this.overlayCube.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
            this.overlayCube.edgesWidth = 2;
            this.overlayCube.doNotSerialize = true;
            this.overlayCube.enableEdgesRendering();
            this.overlayCube.convertToUnIndexedMesh();
            this.overlayCube.freezeNormals();
            this.ghostBox.isVisible = false;
            this.ghostBox.isPickable = false;
            this.ghostBox.visibility = 0.1;
            this.ghostBox.renderOverlay = true;
            this.ghostBox.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
            this.ghostBox.overlayAlpha = 0.5;
            this.ghostBox.edgesWidth = 6;
            this.ghostBox.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
            this.ghostBox.doNotSerialize = true;
            this.ghostBox.enableEdgesRendering();
            this.ghostBox.convertToUnIndexedMesh();
            this.ghostBox.freezeNormals();
            this.clearGhostVoxels(); // init

            this.workPlane.position.y = -0.5;
            this.workPlane.bakeCurrentTransformIntoVertices();
            resetPivot(this.workPlane);
            this.workPlane.material = material.mat_workplane;
            this.workPlane.isVisible = false;
            this.workPlane.isPickable = true;
            this.workPlane.visibility = 0.3;
            this.workPlane.renderOverlay = true;
            this.workPlane.overlayColor = BABYLON.Color3.FromHexString(COL_AQUA);
            this.workPlane.overlayAlpha = 0.05;
            this.workPlane.doNotSerialize = true;
            this.workPlane.convertToUnIndexedMesh();
            this.workPlane.freezeNormals();
            this.setWorkPlane(this.workplaneAxis); // initial
        }

        this.setGrid = function(mesh) {
            setTimeout(() => {
                const bounds = mesh.getBoundingInfo();
                const center = bounds.boundingSphere.center;
                const radius = bounds.boundingSphere.radius;
                animator(this.gridPlane, 'position', this.gridPlane.position, new BABYLON.Vector3(center.x, -0.5, center.z), 5, 2);
                animator(this.gridPlane, 'scaling',  this.gridPlane.scaling,  new BABYLON.Vector3(radius * 2, radius * 2, 1), 5, 2);
                this.gridPlane.material.gridRatio = 0.5 / radius;
                if (this.gridPlane.material.gridRatio < 0.01) // enlarge grid unit
                    this.gridPlane.material.gridRatio *= 2;   // for larger meshes
            }, 0);
        }

        this.toggleWorkplane = function() {
            this.workPlane.isVisible = !this.workPlane.isVisible;
            ui.domWorkplane.checked = this.workPlane.isVisible;
            if (this.workPlane.isVisible) {
                uix.bindWorkplane();
            } else {
                uix.unbindWorkplane();
            }
        }

        this.setWorkPlane = function(axis) { // BABYLON.Axis.X
            this.workplaneAxis = axis;
            this.workPlane.rotation = BABYLON.Vector3.Zero();
            if (axis.x == 1) this.workPlane.rotation.y = PIH;
            if (axis.y == 1) this.workPlane.rotation.x = PIH;
            if (axis.z == 1) this.workPlane.rotation.z = PIH;
        }

        this.resetWorkplane = function(axis) { // BABYLON.Axis.X
            if (axis.x == 1) { this.workPlane.position.x = 0;    this.setWorkPlane(BABYLON.Axis.X); }
            if (axis.y == 1) { this.workPlane.position.y = -0.5; this.setWorkPlane(BABYLON.Axis.Y); }
            if (axis.z == 1) { this.workPlane.position.z = 0;    this.setWorkPlane(BABYLON.Axis.Z); }
        }

        this.setAxisPlane = function(axis, pos) { // BABYLON.Axis.X
            this.axisPlane.isVisible = true;
            this.axisPlane.position = pos;
            this.axisPlane.rotation = BABYLON.Vector3.Zero();
            if (axis.x == 1) this.axisPlane.rotation.y = PIH;
            if (axis.y == 1) this.axisPlane.rotation.x = PIH;
            if (axis.z == 1) this.axisPlane.rotation.z = PIH;
        }

        this.clearAxisPlane = function() {
            this.axisPlane.isVisible = false;
        }

        this.setOverlayPlane = function(pos, normAxis, hex = null) {
            this.overlayPlane.isVisible = true;
            this.overlayPlane.position = pos;
            this.overlayPlane.rotationQuaternion = BABYLON.Quaternion.RotationAxis(
                BABYLON.Vector3.Cross(BABYLON.Axis.Z, normAxis),         // axis
                Math.acos(BABYLON.Vector3.Dot(normAxis, BABYLON.Axis.Z)) // angle
            );
            if (hex) {
                this.overlayPlane.overlayColor = BABYLON.Color3.FromHexString(hex);
                this.overlayPlane.edgesColor = BABYLON.Color4.FromHexString(hex + 'FF');
            } else {
                this.overlayPlane.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
                this.overlayPlane.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
            }
        }

        this.setOverlayCube = function(pos, hex = null) {
            this.overlayCube.isVisible = true;
            this.overlayCube.position = pos;
            if (hex) {
                this.overlayCube.overlayColor = BABYLON.Color3.FromHexString(hex);
                this.overlayCube.edgesColor = BABYLON.Color4.FromHexString(hex + 'FF');
            } else {
                this.overlayCube.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
                this.overlayCube.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
            }
        }

        this.clearOverlays = function() {
            this.overlayCube.isVisible = false;
            this.overlayPlane.isVisible = false;
            this.ghostBox.isVisible = false;
        }

        this.drawGhostBox = function(pos, scale, hex) {
            this.ghostBox.isVisible = true;
            this.ghostBox.position = pos;
            this.ghostBox.scaling = scale;
            this.ghostBox.edgesWidth = 8;
            this.ghostBox.overlayColor = BABYLON.Color3.FromHexString(hex);
        }

        this.cloneGhostVoxel = function(pos, hex = '#C58A1B') {
            this.ghostVoxel.isVisible = true;
            this.ghostVoxel.material.diffuseColor = BABYLON.Color3.FromHexString(hex);
            this.ghostVoxel.thinInstanceAdd( BABYLON.Matrix.Translation(pos.x, pos.y, pos.z) );
        }

        this.clearGhostVoxels = function() {
            if (this.ghostVoxel) // dispose all instances
                this.ghostVoxel.dispose();
            this.ghostVoxel = BABYLON.MeshBuilder.CreateBox("ghostvoxel", { size: 1, sideOrientation: BABYLON.Mesh.FRONTSIDE, updatable: false }, scene);
            this.ghostVoxel.material = material.mat_ghost;
            this.ghostVoxel.isVisible = false;
        }

        this.init();
    }


    // -------------------------------------------------------
    // Tool, ToolBakery


    function Tool(scene) {
        this.name = 'camera';
        this.selected = [];
        this.isMouseDown = false;
        this.lastCamPos = null;
        this.pick = null;
        let startPos = null;

        this.init = function() {
            this.toolSelector(this.name); // startup tool
        }

        this.add = function(pos) {
            helper.cloneGhostVoxel(pos, currentColor);
            this.selected.push(pos);
        }

        this.addSymmetry = function(pos) {
            pos = symmetry.invertPos(pos);
            this.add(pos);
        }

        this.remove = function(pos) {
            helper.cloneGhostVoxel(pos, COL_DELETE);
            this.selected.push(pos); // removing voxels onToolUp to prevent infinite-depth picking
        }

        this.removeSymmetry = function(pos) {
            this.remove(symmetry.invertPos(pos));
        }

        this.paint = function(index, pos) {
            builder.setVoxelColor(index, currentColor);
            helper.cloneGhostVoxel(pos, currentColor);
        }

        this.paintSymmetry = function(pos) {
            const index = symmetry.findIndexInvert(pos);
            if (index > -1) {
                builder.setVoxelColor(index, currentColor);
                helper.cloneGhostVoxel(builder.voxels[index].position, currentColor);
            }
        }

        this.eyedrop = function(hex) {
            currentColor = hex;
            uix.colorPicker.value = BABYLON.Color3.FromHexString(currentColor);
        }

        this.bucket = function(hex) {
            for (let i = 0; i < builder.voxels.length; i++) {
                if (builder.voxels[i].color === hex) {
                    builder.voxels[i].color = currentColor;
                }
            }
        }

        this.hideColor = function(hex) {
            palette.setColorVisible(hex, false);
        }
        
        this.bakeColor = function(hex) {
            bakery.bakeColor(hex);
        }

        this.pull = function(posBegin, posEnd, index) {
            for (let i = 0; i < this.selected.length; i++) { // prevent infinite-depth picking
                if (this.selected[i].equals(posBegin))
                    return;
            }
            if (builder.findIndexByPosition(posEnd) == -1) {  // no duplicates on merge,
                builder.setVoxelPosition(index, posEnd);      // e.g. transform cause a merge of two parallel voxels
                builder.SPS.setParticles(index, index, true);
                this.selected.push(posEnd);
            }
        }

        this.pullSymmetry = function(posBegin, posEnd, index, axis) {
            index = symmetry.findIndexInvert(posBegin, axis);
            if (index == -1) return;
            posEnd = symmetry.invertPos(posEnd, axis);
            this.pull(posBegin, posEnd, index);
        }

        this.pullColor = function(norm, hex) {
            for (let i = 0; i < builder.voxels.length; i++) {
                if (builder.voxels[i].color == hex) {
                    builder.voxels[i].position.addInPlace(norm);
                }
            }
        }

        let fixedHeight = 0;
        let sX,sY,sZ, eX,eY,eZ;
        this.box = function(endPos, isAdd, hex = null) {
            if (isAdd && fixedHeight > 0) // enable wall drawing
                endPos.y = startPos.y + fixedHeight - 1;

            if (endPos.x <= startPos.x && endPos.y <= startPos.y && endPos.z <= startPos.z) {
                sX = endPos.x;
                sY = endPos.y;
                sZ = endPos.z;
                eX = startPos.x;
                eY = startPos.y;
                eZ = startPos.z;
            }
            if (startPos.x <= endPos.x && startPos.y <= endPos.y && startPos.z <= endPos.z) {
                sX = startPos.x;
                sY = startPos.y;
                sZ = startPos.z;
                eX = endPos.x;
                eY = endPos.y;
                eZ = endPos.z;
            }

            if (endPos.x <= startPos.x && startPos.y <= endPos.y && endPos.z <= startPos.z) {
                sX = endPos.x;
                sY = startPos.y;
                sZ = endPos.z;
                eX = startPos.x;
                eY = endPos.y;
                eZ = startPos.z;
            }
            if (startPos.x <= endPos.x && endPos.y <= startPos.y && startPos.z <= endPos.z) {
                sX = startPos.x;
                sY = endPos.y;
                sZ = startPos.z;
                eX = endPos.x;
                eY = startPos.y;
                eZ = endPos.z;
            }

            if (startPos.x <= endPos.x && endPos.y <= startPos.y && endPos.z <= startPos.z) {
                sX = startPos.x;
                sY = endPos.y;
                sZ = endPos.z;
                eX = endPos.x;
                eY = startPos.y;
                eZ = startPos.z;
            }
            if (endPos.x <= startPos.x && startPos.y <= endPos.y && startPos.z <= endPos.z) {
                sX = endPos.x;
                sY = startPos.y;
                sZ = startPos.z;
                eX = startPos.x;
                eY = endPos.y;
                eZ = endPos.z;
            }

            if (startPos.x <= endPos.x && startPos.y <= endPos.y && endPos.z <= startPos.z) {
                sX = startPos.x;
                sY = startPos.y;
                sZ = endPos.z;
                eX = endPos.x;
                eY = endPos.y;
                eZ = startPos.z;
            }
            if (endPos.x <= startPos.x && endPos.y <= startPos.y && startPos.z <= endPos.z) {
                sX = endPos.x;
                sY = endPos.y;
                sZ = startPos.z;
                eX = startPos.x;
                eY = startPos.y;
                eZ = endPos.z;
            }

            helper.drawGhostBox(
                startPos.add(endPos).divide(new BABYLON.Vector3(2, 2, 2)),
                new BABYLON.Vector3(1 + eX - sX, 1 + eY - sY, 1 + eZ - sZ),
                hex);

            this.selected = [];
            for (let x = sX; x <= eX; x++) {
                for (let y = sY; y <= eY; y++) {
                    for (let z = sZ; z <= eZ; z++) {
                        this.selected.push(new BABYLON.Vector3(x, y, z));
                    }
                }
            }
        }

        let selVoxels = [];
        function castRay(position) { // TODO: slow ray cast on SPS mesh
            const ray = BABYLON.Ray.CreateNewFromTo(camera.camera0.position.clone(), position);
            //BABYLON.RayHelper.CreateAndShow(ray, scene, new BABYLON.Color3(0, 1, 1));
            return !ray.intersectsMesh(builder.SPS.mesh, true).hit;
        }
        this.fill = function(norm) {
            const endPos = { x: scene.pointerX, y: scene.pointerY };
            const minX = Math.min(startPos.x, endPos.x);
            const minY = Math.min(startPos.y, endPos.y);
            const maxX = Math.max(startPos.x, endPos.x);
            const maxY = Math.max(startPos.y, endPos.y);
            ui.domMarquee.style.top = minY + 'px';
            ui.domMarquee.style.left = minX + 'px';
            ui.domMarquee.style.width = maxX - minX + 'px';
            ui.domMarquee.style.height = maxY - minY + 'px';

            selVoxels = builder.voxels.filter((i) => 
                isTargetIn(startPos, endPos, i.position, scene.activeCamera)
                && castRay(i.position.add(norm)));

            this.selected = [];
            helper.clearGhostVoxels();
            for (let i = 0; i < selVoxels.length; i++) {
                const pos = selVoxels[i].position.add(norm);
                helper.cloneGhostVoxel(pos, currentColor);
                this.selected.push(pos);
            }
        }

        this.pickWorkplane = function(pick, norm) {
            const pos = pick.pickedPoint.floor();
            if (helper.workplaneAxis.x == 1) {
                if (norm.x < 0) pos.x = helper.workPlane.position.x + 0.5;
                if (norm.x > 0) pos.x = helper.workPlane.position.x - 0.5;
                pos.y += 1;
                pos.z += 0.5;
             }
            if (helper.workplaneAxis.y == 1) {
                pos.x += 0.5;
                if (norm.y < 0) pos.y = helper.workPlane.position.y + 0.5;
                if (norm.y > 0) pos.y = helper.workPlane.position.y - 0.5;
                pos.z += 0.5;
            }
            if (helper.workplaneAxis.z == 1) {
                pos.x += 0.5;
                pos.y += 1;
                if (norm.z < 0) pos.z = helper.workPlane.position.z + 0.5;
                if (norm.z > 0) pos.z = helper.workPlane.position.z - 0.5;
            }
            return pos;
        }

        this.onToolDown = function(pick) {
            if (pick && pick.faceId == -1) return;
            if (!this.pauseCameraControls()) return;
            const index = builder.SPS.pickedParticles[pick.faceId].idx;
            const norm = pick.getNormal(true);
            let pos = builder.SPS.particles[index].position;

            if (pick.pickedMesh == helper.workPlane) {
                if (!['add', 'boxadd', 'fill'].includes(this.name))
                    return;
                pos = this.pickWorkplane(pick, norm);
            }

            switch (this.name) {
                case 'add':
                    this.add(pos.add(norm));
                    if (symmetry.axis !== '')
                        this.addSymmetry(pos.add(norm));
                    break;
                case 'remove':
                    this.remove(pos);
                    if (symmetry.axis !== '')
                        this.removeSymmetry(pos);
                    break;
                case 'pull':
                    this.pull(pos, pos.add(norm), index);
                    if (symmetry.axis !== '')
                        this.pullSymmetry(pos, pos.add(norm), index, symmetry.axis);
                    updateShadowMap(); // important
                    break;
                case 'pullcolor':
                    this.pullColor(norm, builder.voxels[index].color);
                    updateShadowMap();
                    break;
                case 'paint':
                    this.paint(index, pos);
                    if (symmetry.axis !== '')
                        this.paintSymmetry(pos);
                    break;
                case 'eyedrop':
                    this.eyedrop(builder.voxels[index].color);
                    break;
                case 'bucket':
                    this.bucket(builder.voxels[index].color);
                    break;
                case 'hidecolor':
                    this.hideColor(builder.voxels[index].color);
                    break;
                case 'bakecolor':
                    this.bakeColor(builder.voxels[index].color);
                    break;
                case 'boxadd':
                    this.selected.push(pos.add(norm)); // allow to draw one voxel
                    if (symmetry.axis !== '')
                        this.addSymmetry(pos.add(norm));
                    startPos = pos.add(norm);
                    fixedHeight = parseInt(ui.domBoxToolHeight.value);
                    break;
                case 'boxrem':
                    this.selected.push(pos);  // allow to remove one voxel
                    if (symmetry.axis !== '')
                        this.removeSymmetry(pos);
                    startPos = pos;
                    break;
                case 'boxpaint':
                    this.selected.push(pos);
                    startPos = pos;
                    break;
                case 'boxbake':
                    startPos = pos;
                    break;
                case 'boxhide':
                    this.selected.push(pos);
                    startPos = pos;
                    break;
                case 'fill':
                    startPos = { x: scene.pointerX, y: scene.pointerY };
                    ui.domMarquee.style.display = 'unset';
                    break;
            }
        }

        this.onToolMove = function(pick) {
            if (pick && pick.faceId == -1) return;
            const index = builder.SPS.pickedParticles[pick.faceId].idx;
            const norm = pick.getNormal(true);
            let pos = builder.SPS.particles[index].position;

            if (pick.pickedMesh == helper.workPlane) {
                if (!['add', 'boxadd', 'fill'].includes(this.name))
                    return;
                pos = this.pickWorkplane(pick, norm);
            }

            switch (this.name) {
                case 'add':
                    helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm);
                    if (this.isMouseDown && this.pauseCameraControls()) {
                        this.add(pos.add(norm));
                        if (symmetry.axis !== '')
                            this.addSymmetry(pos.add(norm));
                    }
                    break;
                case 'remove':
                    helper.setOverlayCube(pos, COL_DELETE);
                    if (this.isMouseDown && this.pauseCameraControls()) {
                        this.remove(pos);
                        if (symmetry.axis !== '')
                            this.removeSymmetry(pos);
                    }
                    break;
                case 'pull':
                    helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm);
                    if (this.isMouseDown && this.pauseCameraControls()) {
                        this.pull(pos, pos.add(norm), index);
                        if (symmetry.axis !== '')
                            this.pullSymmetry(pos, pos.add(norm), index, symmetry.axis);
                        updateShadowMap(); // important
                    }
                    break;
                case 'pullcolor':
                    helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm);
                    break;
                case 'paint':
                    helper.setOverlayCube(pos);
                    if (this.isMouseDown && this.pauseCameraControls()) {
                        this.paint(index, pos);
                        if (symmetry.axis !== '')
                            this.paintSymmetry(pos);
                    }
                    break;
                case 'eyedrop':
                    helper.setOverlayCube(pos);
                    if (this.isMouseDown && this.pauseCameraControls())
                        this.eyedrop(builder.voxels[index].color);
                    break;
                case 'bucket':
                    helper.setOverlayCube(pos);
                    break;
                case 'hidecolor':
                    helper.setOverlayCube(pos);
                    break;
                case 'bakecolor':
                    helper.setOverlayCube(pos);
                    break;
                case 'boxadd':
                    helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm);
                    if (this.isMouseDown && this.pauseCameraControls())
                        this.box(pos.add(norm), true, currentColor);
                    break;
                case 'boxrem':
                    helper.setOverlayCube(pos, COL_DELETE);
                    if (this.isMouseDown && this.pauseCameraControls())
                        this.box(pos, false, COL_DELETE);
                    break;
                case 'boxpaint':
                    helper.setOverlayCube(pos);
                    if (this.isMouseDown && this.pauseCameraControls())
                        this.box(pos, false, currentColor);
                    break;
                case 'boxbake':
                    helper.setOverlayCube(pos);
                    if (this.isMouseDown && this.pauseCameraControls())
                        this.box(pos, false, COL_BAKE);
                    break;
                case 'boxhide':
                    helper.setOverlayCube(pos);
                    if (this.isMouseDown && this.pauseCameraControls())
                        this.box(pos, false, COL_HIDE);
                    break;
                case 'fill':
                    helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm);
                    if (this.isMouseDown && this.pauseCameraControls())
                        this.fill(norm);
                    break;
            }
        }

        this.onToolUp = function() {
            if (!this.pauseCameraControls()) return;
            switch (this.name) {
                case 'add':
                    if (this.selected.length > 0) {
                        for (let i = 0; i < this.selected.length; i++)
                            builder.addNoDup(this.selected[i], currentColor, true);
                        builder.createSPS();
                        palette.create();
                        memory.record();
                    }
                    break;
                case 'remove':
                    if (this.selected.length > 0) {
                        for (let i = 0; i < this.selected.length; i++)
                            builder.removeByPosition(this.selected[i]);
                        builder.createSPS();
                        palette.create();
                        memory.record();
                    }
                    break;
                case 'pull':
                    builder.createSPS();
                    palette.create();
                    memory.record();
                    break;
                case 'pullcolor':
                    builder.createSPS();
                    palette.create();
                    memory.record();
                    break;
                case 'paint':
                    builder.createSPS();
                    palette.create();
                    memory.record();
                    break;
                case 'bucket':
                    builder.createSPS();
                    palette.create();
                    memory.record();
                    break;
                case 'hidecolor':
                    palette.create();
                    break;
                case 'bakecolor':
                    break;
                case 'boxadd':
                    if (this.selected.length > 0) {
                        for (let i = 0; i < this.selected.length; i++) {
                            builder.addNoDup(this.selected[i], currentColor, true);
                            if (symmetry.axis !== '')
                                builder.addNoDup(symmetry.invertPos(this.selected[i]), currentColor, true);
                        }
                        builder.createSPS();
                        palette.create();
                        memory.record();
                    }
                    break;
                case 'boxrem':
                    if (this.selected.length > 0) {
                        for (let i = 0; i < this.selected.length; i++) {
                            builder.removeByPosition(this.selected[i]);
                            if (symmetry.axis !== '')
                                builder.removeByPosition(symmetry.invertPos(this.selected[i]));
                        }
                        builder.createSPS();
                        palette.create();
                        memory.record();
                    }
                    break;
                case 'boxpaint':
                    if (this.selected.length > 0) {
                        for (let i = 0; i < this.selected.length; i++) {
                            let idx = builder.findIndexByPosition(this.selected[i]);
                            if (idx > -1) {
                                builder.voxels[idx].color = currentColor;
                                if (symmetry.axis !== '') {
                                    idx = builder.findIndexByPosition(symmetry.invertPos(this.selected[i]));
                                    if (idx > -1)
                                        builder.voxels[idx].color = currentColor;
                                }
                            }
                        }
                        builder.createSPS();
                        palette.create();
                        memory.record();
                    }
                    break;
                case 'boxbake':
                    if (this.selected.length > 0) {
                        let voxels = [];
                        for (let i = 0; i < this.selected.length; i++) {
                            const idx = builder.findIndexByPosition(this.selected[i]);
                            if (idx > -1)
                                voxels.push(builder.voxels[idx]);
                        }
                        if (voxels.length > 0)
                            bakery.newBake(voxels);
                        voxels = null;
                    }
                    break;
                case 'boxhide':
                    if (this.selected.length > 0) {
                        for (let i = 0; i < this.selected.length; i++) {
                            const idx = builder.findIndexByPosition(this.selected[i]);
                            if (idx > -1)
                                builder.setVoxelVisible(idx, false);
                        }
                        builder.SPS.setParticles();
                        palette.create();
                        updateShadowMap();
                    }
                    break;
                case 'fill':
                    if (this.selected.length > 0) {
                        for (let i = 0; i < this.selected.length; i++)
                            builder.addNoDup(this.selected[i], currentColor, true);
                        builder.createSPS();
                        palette.create();
                        memory.record();
                    }
                    break;
            }
        }

        const predicate = function(mesh) {
            if (helper.workPlane.isVisible) {
                return mesh.name == 'SPS' || mesh == helper.workPlane;
            } else {
                return mesh.name == 'SPS';
            }
        };

        this.handleToolDown = function(ev) {
            this.isMouseDown = true;
            this.lastCamPos = scene.activeCamera.position.clone();
            if (this.name !== 'camera') {
                this.pick = scene.pick(scene.pointerX, scene.pointerY, predicate);
                tool.onToolDown(this.pick);
            }
        }

        this.handleToolMove = function(ev) {
            if (this.name !== 'camera') { // speed up navigation
                setTimeout(() => {
                    this.pick = scene.pick(scene.pointerX, scene.pointerY, predicate);
                    tool.onToolMove(this.pick);
                    
                    if (!this.pick.hit) { // important: prevent last ghost/overlay after drawing
                        helper.clearOverlays();
                    }
                }, FPS_TOOLMOVE);
            }
        }

        this.handleToolUp = function(ev) {
            this.isMouseDown = false;
            if (this.name !== 'camera') {
                tool.onToolUp();

                this.selected = [];
                helper.clearGhostVoxels();
                setTimeout(() => { // a little hack to prevent last ghost/overlay
                    helper.clearOverlays(); // in touchscreen
                }, 0);
                ui.domMarquee.style = "display: none; left: 0; top: 0; width: 0; height: 0;";
                ui.updateStatus();
            }
            scene.activeCamera.attachControl(canvas, true);
        }

        this.toolSelector = function(toolName) {
            this.name = toolName;

            const elem = document.getElementsByClassName('tool_' + this.name);
            for (let i of document.querySelectorAll('li'))
                if (i.classList.contains("tool_selector"))
                    i.classList.remove("tool_selector");
            for (let i of document.querySelectorAll('button'))
                if (i.classList.contains("tool_selector"))
                    i.classList.remove("tool_selector");
            for (let i = 0; i < elem.length; i++)
                elem[i].classList.add("tool_selector");

            helper.clearOverlays();
        }

        this.pauseCameraControls = function() { // prevent drawing and camera-control conflict
            if (this.lastCamPos.x !== scene.activeCamera.position.x &&
                this.lastCamPos.y !== scene.activeCamera.position.y &&
                this.lastCamPos.z !== scene.activeCamera.position.z)
                return false;
            scene.activeCamera.detachControl(canvas);
            return true;
        }

        this.init();
    }

    function ToolBakery(scene) {
        this.name = 'xform';
        this.selected = [];
        this.pick = null;

        this.onToolDown = function() {
            this.pick = scene.pick(scene.pointerX, scene.pointerY, function (mesh) {
                return bakery.meshes.includes(mesh);
            });

            if (!this.pick.hit) {
                bakery.clearSelected();
                uix.unbindGizmo();
                return;
            }

            switch (this.name) {
                case 'xform': // bind transform gizmo to baked meshes
                    bakery.clearSelected();
                    uix.bindGizmo([this.pick.pickedMesh]);
                    break;
                case 'merge': // merge by select and apply
                    const idx = this.selected.indexOf(this.pick.pickedMesh);
                    if (idx == -1) {
                        this.selected.push(this.pick.pickedMesh);
                        this.pick.pickedMesh.edgesWidth = 4;
                        this.pick.pickedMesh.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
                        this.pick.pickedMesh.enableEdgesRendering();
                    } else {
                        this.selected.splice(idx, 1);
                        this.pick.pickedMesh.disableEdgesRendering();
                    }
                    break;
            }
        }

        this.onToolMove = function() {
            //
        }

        this.onToolUp = function() {
            //
        }

        this.mergeBakes = function() {
            if (this.selected.length == 1) {
                ui.notification('pick more bakes...');
                return;
            }
            if (this.selected.length > 1) {
                for (let i = 0; i < bakery.meshes.length; i++)
                    bakery.meshes[i].renderOverlay = false;

                bakery.mergeSelected(this.selected);

                for (let i = 0; i < this.selected.length; i++)
                    this.selected[i].disableEdgesRendering();

                this.selected = [];
                this.toolSelector('xform');
            } else {
                ui.notification('pick, select bakes and hit merge');
            }
        }

        this.cancelTools = function() {
            if (this.selected.length > 0) {
                for (let i = 0; i < this.selected.length; i++)
                    this.selected[i].disableEdgesRendering();
                this.selected = [];
            }
            this.toolSelector('xform');
        }

        this.onGizmoAttached = function(mesh) {
            bakery.clearSelected(); // on user select
            bakery.selectMesh(mesh);
            if (ui.domMaterialAutoUpdate.checked)
                bakery.getMaterial();
        }

        this.toolSelector = function(toolName) {
            this.name = toolName;

            for (let i of document.querySelectorAll('li'))
                if (i.classList.contains("tool_bakery_selector"))
                    i.classList.remove("tool_bakery_selector");
            for (let i of document.querySelectorAll('button'))
                if (i.classList.contains("tool_bakery_selector"))
                    i.classList.remove("tool_bakery_selector");
            const elem = document.getElementsByClassName('tool_' + this.name)[0];
            if (elem)
                elem.classList.add("tool_bakery_selector");

            bakery.clearSelected();
            uix.unbindGizmo();
        }
    }


    // -------------------------------------------------------
    // Symmetry


    function Symmetry() {
        this.axis = ''; // 'x'

        this.setAxis = function(axis) {
            this.axis = axis;
            helper.clearAxisPlane();
            if (axis == 'x') {
                helper.setAxisPlane(BABYLON.Axis.X, BABYLON.Vector3.Zero());
                ui.domSymmAxis.innerHTML = 'X';
                ui.domSymmAxis.style.color = '#EA3751';
                ui.domSymmAxis2.innerHTML = 'X';
                ui.domSymmAxis2.style.color = '#EA3751';
            } else if (axis == 'y') {
                helper.setAxisPlane(BABYLON.Axis.Y, BABYLON.Vector3.Zero());
                ui.domSymmAxis.innerHTML = 'Y';
                ui.domSymmAxis.style.color = '#85D10C';
                ui.domSymmAxis2.innerHTML = 'Y';
                ui.domSymmAxis2.style.color = '#85D10C';
            } else if (axis == 'z') {
                helper.setAxisPlane(BABYLON.Axis.Z, BABYLON.Vector3.Zero());
                ui.domSymmAxis.innerHTML = 'Z';
                ui.domSymmAxis.style.color = '#2F81DF';
                ui.domSymmAxis2.innerHTML = 'Z';
                ui.domSymmAxis2.style.color = '#2F81DF';
            } else {
                ui.domSymmAxis.innerHTML = 'None';
                ui.domSymmAxis.style.color = '#98a1ac';
                ui.domSymmAxis2.innerHTML = 'S';
                ui.domSymmAxis2.style.color = '#FB4BFB';
            }
        }

        this.switchAxis = function() {
            if (this.axis == '') {
                this.setAxis('x');
            } else if (this.axis == 'x') {
                this.setAxis('y');
            } else if (this.axis == 'y') {
                this.setAxis('z');
            } else if (this.axis == 'z') {
                this.setAxis('');
                this.resetAxis();
            }
        }

        this.resetAxis = function() {
            this.setAxis('');
        }

        this.symmetrizeVoxelPositions = function(side) {
            if (this.axis == '') {
                ui.notification('select symmetry axis');
                return;
            }
            builder.setVoxelsVisibility(true);
            if (side == 1) { // pos-to-neg
                this.deleteHalf(1);
                this.mirrorVoxels();
            } else { // neg-to-pos
                this.deleteHalf(-1);
                this.mirrorVoxels();
            }
            builder.createSPS();
            palette.create();
            memory.record();
        }

        this.mirrorVoxelPositions = function() {
            if (this.axis == '') {
                ui.notification('select symmetry axis');
                return;
            }
            builder.setVoxelsVisibility(true);
            this.invertVoxels();
            builder.createSPS();
            palette.create();
            memory.record();
        }

        this.deleteHalfVoxels = function(side) {
            if (this.axis == '') {
                ui.notification('select symmetry axis');
                return;
            }
            builder.setVoxelsVisibility(true);
            this.deleteHalf(side);
            builder.createSPS();
            palette.create();
            memory.record();
        }

        this.deleteHalf = function(side) { // preserve 0 borders, prevent duplicates at the middle
            let p = null; // modo reminder: 0.00000001 for vertex, voxel is 1.0, >=0.1 is more than enough!
            for (let i = 0; i < builder.SPS.particles.length; i++) {
                p = builder.SPS.particles[i].position;
                if (this.axis == 'x') {
                    if (side == -1 && this.center(p.x) <= -0.1) builder.removeByPosition(p);
                    if (side == 1  && this.center(p.x) >= 0.1)  builder.removeByPosition(p);
                }
                if (this.axis == 'y') {
                    if (side == -1 && this.center(p.y) <= -0.1) builder.removeByPosition(p);
                    if (side == 1  && this.center(p.y) >= 0.1)  builder.removeByPosition(p);
                }
                if (this.axis == 'z') {
                    if (side == -1 && this.center(p.z) <= -0.1) builder.removeByPosition(p);
                    if (side == 1  && this.center(p.z) >= 0.1)  builder.removeByPosition(p);
                }
            }
            p = null;
        }

        this.mirrorVoxels = function() {
            for (let i = 0; i < builder.voxels.length; i++)
                builder.addNoDup(this.invertPos(builder.voxels[i].position), builder.voxels[i].color, true);
        }

        this.invertVoxels = function() {
            for (let i = 0; i < builder.voxels.length; i++) {
                builder.voxels[i].position = this.invertPos(builder.voxels[i].position);
            }
        }

        this.invertPos = function(pos) { // invert positive to negative and reverse
            if (this.axis == 'x') pos = new BABYLON.Vector3(this.center2(pos.x), pos.y, pos.z);
            if (this.axis == 'y') pos = new BABYLON.Vector3(pos.x, this.center2(pos.y), pos.z);
            if (this.axis == 'z') pos = new BABYLON.Vector3(pos.x, pos.y, this.center2(pos.z));
            return pos;
        }

        this.center = function(p) { // calculate position from center
            const center = builder.SPS.mesh.getBoundingInfo().boundingBox.centerWorld;
            if (this.axis == 'x') return center.x - p;
            if (this.axis == 'y') return center.y - p;
            if (this.axis == 'z') return center.z - p;
        }

        this.center2 = function(p) { // calculate position from center*2
            const center = builder.SPS.mesh.getBoundingInfo().boundingBox.centerWorld;
            if (this.axis == 'x') return (center.x * 2) - p;
            if (this.axis == 'y') return (center.y * 2) - p;
            if (this.axis == 'z') return (center.z * 2) - p;
        }

        this.findIndexInvert = function(pos) {
            pos = this.invertPos(pos);    // return index at mirrored position,
            return builder.findIndexByPosition(pos); // or '-1' if not exist
        }
    }
    
    
    // -------------------------------------------------------
    // Voxelizer


    function Voxelizer() {
        this.voxelize = function(mesh) {
            const scale = parseInt(document.getElementById('input-voxelizer-scale').value);
            const dense = parseInt(document.getElementById('input-voxelizer-dense').value);
            
            // calculate random points per surface area,
            // voxel is 1x1x1, larger mesh size require more voxels,
            // and longer surface require more points to fill details.
            normalizeMesh(mesh, scale);
            let points = getRandomPointsOnMeshSurface(mesh, dense);

            let data = [];
            for (let i = 0; i < points.length; i++) {
                data.push({ position: points[i], color: currentColor, visible: true });
            }
            builder.loadData(data, false, true);
            memory.clear();
            symmetry.resetAxis();
            camera.frame();
            
            points = null;
            data = null;
        }

        this.voxelize2D = function(imgData) {
            engine.displayLoadingUI();
            const ratio = parseFloat(document.getElementById('input-voxelizer-ratio').value);
            const zUp = parseBool(document.getElementById('input-voxelizer-zup').checked);
            const img = new Image();
            img.src = imgData;
            img.onload = () => {
                const c = document.createElement('canvas');
                const cx = c.getContext('2d');

                const dim = aspectRatioFit(img.width, img.height, 10*ratio, 10*ratio);
                c.width = dim.width;
                c.height = dim.height;

                cx.msImageSmoothingEnabled = false;
                cx.mozImageSmoothingEnabled = false;
                cx.webkitImageSmoothingEnabled = false;
                cx.imageSmoothingEnabled = false;
                cx.drawImage(img, 0, 0, c.width, c.height);

                let data = [];
                let imageData = cx.getImageData(0, 0, c.width, c.height).data;
                let x,y,r,g,b,a;
                for (let i = 0; i < imageData.length; i += 4) {
                    if (imageData[i + 3] > 0) {
                        r = imageData[i];
                        g = imageData[i + 1];
                        b = imageData[i + 2];
                        x = (i / 4) % c.width;
                        y = ~~(i / 4 / c.width);
                        if (zUp) {
                            data.push({
                                position: new BABYLON.Vector3(x, dim.height-y-1, 0).floor(),
                                color: rgbIntToHex(r, g, b),
                                visible: true
                            });
                        } else {
                            data.push({
                                position: new BABYLON.Vector3(x, 0, y).floor(),
                                color: rgbIntToHex(r, g, b),
                                visible: true
                            });
                        }
                    }
                }
                builder.loadData(data, false, true);
                memory.clear();
                symmetry.resetAxis();
                camera.frame();
                engine.hideLoadingUI();

                data = null;
                imgData = null;
                imageData = null;
            }
        }

        this.importMesh = function(url) {
            engine.displayLoadingUI();
            let mesh = null;
            BABYLON.SceneLoader.LoadAssetContainerAsync(url, "", scene, null, '.obj')
                .then(function(container) {
                    mesh = BABYLON.Mesh.MergeMeshes(container.meshes, true, true);
                    container.removeAllFromScene();
                    voxelizer.voxelize(mesh);
                    mesh.dispose();
                    mesh = null;
                    engine.hideLoadingUI();
                }).catch(function(reason) {
                    if (mesh) mesh.dispose();
                    mesh = null;
                    engine.hideLoadingUI();
                    ui.notification("unable to import model");
                    console.error(reason.message);
                });
        }

        this.pasteBase64Image = function() {
            navigator.clipboard.readText()
                .then(text => {
                    if (text.startsWith('data:image/')) {
                        voxelizer.voxelize2D(text);
                    } else {
                        ui.notification('invalid base64 image');
                    }
                })
                .catch(err => {
                    ui.notification('failed to read clipboard data');
                });
        }

        this.pasteObjBase64 = function() {
            navigator.clipboard.readText()
                .then(text => {
                    if (text.startsWith('data:application/octet-stream;')) {
                        voxelizer.importMesh(text, '.obj');
                    } else {
                        ui.notification('invalid base64 obj');
                    }
                })
                .catch(err => {
                    ui.notification('failed to read clipboard data');
                });
        }

        this.pasteObjUrl = function() {
            navigator.clipboard.readText()
                .then(text => {
                    text = text.toLowerCase();
                    if (text.startsWith('https://') && text.endsWith('.obj')) {
                        voxelizer.importMesh(text, '.obj');
                    } else {
                        ui.notification('invalid url');
                    }
                })
                .catch(err => {
                    ui.notification('failed to read clipboard data');
                });
        }
    }


    // -------------------------------------------------------
    // Generator


    function Generator() {
        this.createGrid = function(isFill) {
            const X = (parseInt(document.getElementById('input-grid-x').value) - 1) / 2;
            const Y = (parseInt(document.getElementById('input-grid-y').value) - 1) / 2;
            const Z = (parseInt(document.getElementById('input-grid-z').value) - 1) / 2;
            let data = [];
            if (isFill) {
                for (let x = -X; x <= X; x++) {
                    for (let y = 0; y <= Y * 2; y++) {
                        for (let z = -Z; z <= Z; z++) {
                            data.push({
                                position: new BABYLON.Vector3(x, y, z),
                                color: currentColor,
                                visible: true
                            });
                        }
                    }
                }
            } else {
                for (let x = -X; x <= X; x++) {
                    for (let y = 0; y <= Y * 2; y++) {
                        for (let z = -Z; z <= Z; z++) {
                            if ((x <= -X || y <= 0 || z <= -Z) ||
                                (x >= X || y >= Y * 2 || z >= Z)) {
                                data.push({
                                    position: new BABYLON.Vector3(x, y, z),
                                    color: currentColor,
                                    visible: true
                                });
                            }
                        }
                    }
                }
            }
            if (data.length > MAXAMOUNT)
                ui.notification('warning: 64k voxel limit', 5000);
            builder.loadData(data, false, false);
            memory.clear();
            symmetry.resetAxis();
            bakery.clearBakes();
            camera.frame();
            data = null;
        }

        this.createIsometric = function() {
            const size = (parseInt(document.getElementById('input-isometric-size').value) - 1) / 2;
            let data = [];
            for (let x = -size; x <= size; x++) {
                for (let y = 0; y <= size * 2; y++) {
                    for (let z = -size; z <= size; z++) {
                        if (x <= -size || y <= 0 || z <= -size) // limit to x,y,z plane
                            data.push({
                                position: new BABYLON.Vector3(x, y, z),
                                color: currentColor,
                                visible: true
                            });
                    }
                }
            }
            builder.loadData(data, false, false);
            memory.clear();
            symmetry.resetAxis();
            bakery.clearBakes();
            camera.frame();
            data = null;
        }

        this.createTerrain = function() {
            const X = parseInt(document.getElementById('input-terrain-x').value) / 2;
            const Y = parseInt(document.getElementById('input-terrain-y').value);
            const Z = parseInt(document.getElementById('input-terrain-z').value) / 2;
            let data = [];
            let xoff = 0;
            let zoff = 0;
            let v = 0;
            let pos = null;
            const perlin = new ClassicalNoise();
            for (let x = -X; x < X; x++) {
                for (let z = -Z; z < Z; z++) {
                    xoff = (0.4/Y) * x; // fill x and z
                    zoff = (0.4/Y) * z; // relative to Y
                    v = Math.round(perlin.noise(xoff, 0, zoff) * Y);
                    pos = new BABYLON.Vector3(x, v, z);
                    data.push({ position: pos, color: currentColor, visible: true });
                }
            }
            if (data.length > MAXAMOUNT)
                ui.notification('warning: 64k voxel limit', 5000);
            builder.loadData(data, false, true);
            memory.clear();
            symmetry.resetAxis();
            bakery.clearBakes();
            camera.frame();
            pos = null;
            data = null;
        }

        this.createSphere = function() { // source: Babylon.js createSphere()
            const X = (parseInt(document.getElementById('input-grid-x').value) - 1) / 2;
            const Y = (parseInt(document.getElementById('input-grid-y').value) - 1) / 2;
            const Z = (parseInt(document.getElementById('input-grid-z').value) - 1) / 2;
            const slice = 1;
            const arc = 1;
            const totalZRotSteps = 2 + ((X+Y+Z) * 2); // pseudo calc
            const totalYRotSteps = 2 * totalZRotSteps;
            let data = [];
            for (let zRotStep = 0; zRotStep <= totalZRotSteps; zRotStep++) {
                const normalizedZ = zRotStep / totalZRotSteps;
                const angleZ = normalizedZ * Math.PI * slice;
                for (let yRotStep = 0; yRotStep <= totalYRotSteps; yRotStep++) {
                    const normalizedY = yRotStep / totalYRotSteps;
                    const angleY = normalizedY * PI2 * arc;
                    const rotationZ = BABYLON.Matrix.RotationZ(-angleZ);
                    const rotationY = BABYLON.Matrix.RotationY(angleY);
                    const afterRotZ = BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Up(), rotationZ);
                    const complete = BABYLON.Vector3.TransformCoordinates(afterRotZ, rotationY);
                    data.push({
                        position: complete.multiply( new BABYLON.Vector3(X, Y, Z) ).floor(),
                        color: currentColor,
                        visible: true
                    });
                }
            }
            if (data.length > MAXAMOUNT)
                ui.notification('warning: 64k voxel limit', 5000);
            builder.loadData(data, true, true);
            memory.clear();
            symmetry.resetAxis();
            bakery.clearBakes();
            camera.frame();
            data = null;
        }
    }


    // -------------------------------------------------------
    // Bakery
    // TODO: multi-material support for merged bakes


    function Bakery(scene) {
        this.meshes = [];
        this.selected = null;
        this.pick = null;
        this.lastSelected = null;
        
        this.bakeToMesh = function(isTestColor, voxels = builder.voxels) {
            const baked = this.reconstructMesh('baked', isTestColor, voxels);
            resetPivot(baked);

            baked.material = material.mat_pbr.clone('baked');

            baked.checkCollisions = true;
            baked.receiveShadows = true;
            scene.lights[1].getShadowGenerator().addShadowCaster(baked);

            this.meshes.push(baked);
        }

        this.newBake = function(voxels = null) {
            engine.displayLoadingUI();
            setTimeout(() => {
                ui.setMode(1);
                material.setPBRTexture();
                material.update();

                if (voxels) {
                    this.bakeToMesh(true, voxels);
                } else {
                    this.bakeToMesh(true);
                }

                uix.bindGizmo(this.meshes[this.meshes.length-1]);
                uix.gizmo.attachToMesh(this.meshes[this.meshes.length-1]);

                camera.frame();
                ui.updateStatus();
                updateShadowMap();
                engine.hideLoadingUI();
            }, 0);
        }

        this.bakeColor = function(hex) {
            engine.displayLoadingUI();
            setTimeout(() => {
                ui.setMode(1);
                material.setPBRTexture();
                material.update();

                let voxels = [];
                for (let i = 0; i < builder.voxels.length; i++) {
                    if (builder.voxels[i].color == hex)
                        voxels.push(builder.voxels[i]);
                }
                this.bakeToMesh(true, voxels);
                voxels = null;

                uix.bindGizmo(this.meshes[this.meshes.length-1]);
                uix.gizmo.attachToMesh(this.meshes[this.meshes.length-1]);

                camera.frame();
                ui.updateStatus();
                updateShadowMap();
                engine.hideLoadingUI();
            }, 0);
        }

        this.bakeAllColors = async function() {
            if (!await ui.showConfirm('Clear and bake all voxels<br>grouped by colors, continue?')) return;
            engine.displayLoadingUI();
            setTimeout(() => {
                ui.setMode(1);
                material.setPBRTexture();
                material.update();
                this.clearBakes();

                for (let i = 0; i < palette.uniqueColors.length; i++) {
                    this.bakeToMesh(true, builder.getVoxelsByColor(palette.uniqueColors[i]));
                }

                camera.frame();
                ui.updateStatus();
                updateShadowMap();
                engine.hideLoadingUI();
            }, 0);
        }

        this.cloneSelected = function() {
            if (this.selected) {
                const clone = this.selected.clone('baked');
                clone.material = this.selected.material.clone('baked');

                clone.checkCollisions = true;
                clone.receiveShadows = true;
                scene.lights[1].getShadowGenerator().addShadowCaster(clone);
                updateShadowMap();

                uix.bindGizmo(clone);
                uix.gizmo.attachToMesh(clone);
                this.highlightMesh(clone);

                this.meshes.push(clone);
                ui.updateStatus();
            } else {
                ui.notification('select a bake');
            }
        }

        this.instanceSelected = function() {
            if (this.selected) {
                const inst = this.selected.createInstance('baked');

                inst.checkCollisions = true;
                inst.receiveShadows = true;
                scene.lights[1].getShadowGenerator().addShadowCaster(inst);
                updateShadowMap();

                uix.bindGizmo(inst);
                uix.gizmo.attachToMesh(inst);

                this.meshes.push(inst);
                ui.updateStatus();
            } else {
                ui.notification('select a bake');
            }
        }

        this.mergeSelected = function(bakes) {
            for (let i = 0; i < bakes.length; i++) { // instances not supported
                if (bakes[i].hasInstances || bakes[i].isAnInstance) {
                    ui.notification('unable to merge instances');
                    return;
                }
            }

            const mesh = BABYLON.Mesh.MergeMeshes(bakes, true, true);
            resetPivot(mesh);
            mesh.name = 'baked_merged';

            for (let i = 0; i < bakes.length; i++) {
                this.meshes.splice(this.meshes.indexOf(bakes[i]), 1);
                if (bakes[i].material) {
                    if (bakes[i].material.albedoTexture)
                        bakes[i].material.albedoTexture.dispose();
                    bakes[i].material.dispose();
                }
                bakes[i].dispose();
            }

            material.setPBRTexture();
            material.update();
            mesh.material = material.mat_pbr.clone('baked');

            mesh.checkCollisions = true;
            mesh.receiveShadows = true;
            scene.lights[1].getShadowGenerator().addShadowCaster(mesh);
            updateShadowMap();

            uix.bindGizmo(mesh);
            uix.gizmo.attachToMesh(mesh);
            
            bakery.meshes.push(mesh);
            ui.updateStatus();
        }

        this.deleteSelected = function() {
            if (this.selected) {
                this.meshes.splice(this.meshes.indexOf(this.selected), 1);
                if (!this.selected.isAnInstance) {
                    if (this.selected.material.albedoTexture)
                        this.selected.material.albedoTexture.dispose();
                    this.selected.material.dispose();
                }
                this.selected.dispose();
                this.selected = null;
                uix.unbindGizmo();
                ui.updateStatus();
                updateShadowMap();
            } else {
                ui.notification('select a bake');
            }
        }

        this.selectMesh = function(mesh) {
            this.selected = mesh;
            if (!mesh.isAnInstance) { // useless, instances not support it anyway
                this.selected.renderOutline = true;
                this.selected.outlineWidth = 0.05;
                this.selected.outlineColor = BABYLON.Color3.FromHexString(COL_ORANGE);
            }
            this.lastSelected = mesh;
        }

        this.highlightMesh = function(mesh) {
            if (!mesh.isAnInstance) {
                mesh.renderOverlay = true;
                mesh.overlayAlpha = 0.3;
                mesh.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
            }
        }

        this.clearSelected = function() {
            if (this.selected)
                this.selected = null;
            for (let i = 0; i < this.meshes.length; i++) {
                this.meshes[i].renderOutline = false;
                this.meshes[i].renderOverlay = false;
            }
        }

        this.setBakesVisibility = function(isVisible) {
            for (let i = 0; i < this.meshes.length; i++)
                this.meshes[i].isVisible = isVisible;
        }

        this.clearBakes = async function(isAlert = false) {
            if (this.meshes.length > 0) {
                if (isAlert && !await ui.showConfirm('This operation is not undoable<br>continue?')) return;
                scene.blockfreeActiveMeshesAndRenderingGroups = true; // save unnecessary
                for (let i = 0; i < this.meshes.length; i++) { // dispose() computation
                    if (!this.meshes[i].isAnInstance) {
                        if (this.meshes[i].material.albedoTexture)
                            this.meshes[i].material.albedoTexture.dispose();
                        if (this.meshes[i].material.reflectionTexture)
                            this.meshes[i].material.reflectionTexture.dispose();
                        this.meshes[i].material.dispose();
                    }
                    this.meshes[i].dispose();
                }
                scene.blockfreeActiveMeshesAndRenderingGroups = false;
                this.meshes = [];
                this.selected = null;
                uix.unbindGizmo();
                ui.updateStatus();
                updateShadowMap();
            }
        }
        
        this.getMaterial = function() {
            if (this.selected) {
                currentColor = this.selected.material.albedoColor.toHexString();
                uix.colorPicker.value = this.selected.material.albedoColor;

                ui.domColorPickerEmissive.value = this.selected.material.emissiveColor.toHexString();
                
                ui.domRoughness.value = this.selected.material.roughness;
                ui.domMetallic.value = this.selected.material.metallic;
                ui.domAlpha.value = this.selected.material.alpha;
            } else {
                ui.notification('select a bake');
            }
        }

        this.setMaterial = function(type) {
            if (this.selected) {
                switch (type) {
                    case 'all':
                        this.selected.material.albedoColor = BABYLON.Color3.FromHexString(currentColor);
                        this.selected.material.roughness = parseFloat(ui.domRoughness.value);
                        this.selected.material.metallic = parseFloat(ui.domMetallic.value);
                        this.selected.material.emissiveColor = BABYLON.Color3.FromHexString(ui.domColorPickerEmissive.value);
                        this.selected.material.alpha = parseFloat(ui.domAlpha.value);
                        this.selected.visibility = parseFloat(ui.domAlpha.value); // set alpha seth!
                        break;
                    case 'albedo':
                        this.selected.material.albedoColor = BABYLON.Color3.FromHexString(currentColor);
                        break;
                    case 'roughness':
                        this.selected.material.roughness = parseFloat(ui.domRoughness.value);
                        break;
                    case 'metallic':
                        this.selected.material.metallic = parseFloat(ui.domMetallic.value);
                        break;
                    case 'emissive':
                        this.selected.material.emissiveColor = BABYLON.Color3.FromHexString(ui.domColorPickerEmissive.value);
                        break;
                    case 'alpha':
                        this.selected.material.alpha = parseFloat(ui.domAlpha.value);
                        this.selected.visibility = parseFloat(ui.domAlpha.value); // set alpha seth!
                        break;
                }
            } else {
                ui.notification('select a bake');
            }
        }

        this.replaceTexture = function() {
            if (this.selected && this.selected.material) {
                if (this.selected.material.albedoTexture)
                    this.selected.material.albedoTexture.dispose();
                this.selected.material.albedoTexture = material.textures[material.texId].clone();
            } else {
                //ui.notification('select a bake');
            }
        }

        this.replaceTextureAll = async function() {
            if (!await ui.showConfirm('This operation is not undoable<br>continue?')) return;
            for (let i = 0; i < bakery.meshes.length; i++) {
                this.selected = bakery.meshes[i];
                this.replaceTexture();
            }
        }

        this.updateReflectionTextures = function() {
            for (let i = 0; i < this.meshes.length; i++) {
                if (!this.meshes[i].isAnInstance) {
                    if (this.meshes[i].material.reflectionTexture)
                        this.meshes[i].material.reflectionTexture.dispose();
                    this.meshes[i].material.reflectionTexture = scene.environmentTexture.clone();
                    this.meshes[i].material.reflectionTexture.coordinatesMode = BABYLON.Texture.CUBIC_MODE;
                }
            }
        }

        this.updateVertexColors = async function(hex = currentColor) {
            if (this.selected) {
                if (!await ui.showConfirm('Set all vertex colors<br>to albedo color, continue?')) return;
                let positions = this.selected.getVerticesData(BABYLON.VertexBuffer.PositionKind);
                let colors = [];
                const rgb = hexToRgbFloat(hex);
                for (let i = 0; i < positions.length/3; i++) {
                    colors.push(rgb.r, rgb.g, rgb.b, 1);
                }
                this.selected.setVerticesData(BABYLON.VertexBuffer.ColorKind, colors);
                positions = null;
                colors = null;
            } else {
                ui.notification('select a bake');
            }
        }

        this.loadBakes = function(url, isLoadBakery) {
            engine.displayLoadingUI();
            BABYLON.SceneLoader.LoadAssetContainerAsync("", url, scene, null, '.glb')
                .then(function(container) {
                    let count = 0;
                    for (let i = 0; i < container.meshes.length; i++) {
                        if (container.meshes[i].name !== '__root__') {
                            const baked = container.meshes[i].clone('baked');
                            baked.setParent(null);
                            baked.metadata = null;
                            // important, GLB exporter flip side-orientation,
                            baked.overrideMaterialSideOrientation = null;
                            baked.flipFaces(false); // can't merge them to new bakes

                            baked.material = container.meshes[i].material.clone('baked');
                            baked.visibility = baked.material.alpha; // reload alpha seth!!
                            
                            baked.checkCollisions = true;
                            baked.receiveShadows = true;
                            scene.lights[1].getShadowGenerator().addShadowCaster(baked);

                            bakery.meshes.push(baked);
                            count += 1;
                        }
                    }
                    container.removeAllFromScene();

                    if (count == 0) {
                        ui.notification('unable to load baked meshes');
                    } else {
                        if (isLoadBakery) {
                            ui.setMode(1);
                        } else {
                            ui.setMode(0);
                        }
                        bakery.updateReflectionTextures();
                        updateShadowMap();
                    }
                    ui.updateStatus();
                    engine.hideLoadingUI();
                }).catch(function(reason) {
                    engine.hideLoadingUI();
                    ui.notification("unable to load bake");
                    console.error(reason.message);
                });
        }

        this.reconstructMesh = function(name, isTestColor, voxels) {
            const isPerFaceUV = ui.domBakeryPerFaceUvs.checked;
            let planes = [];
            let colors = [];
            let plane = null;
            let idx = 0;

            function createSide(index, side, position, nearby, rotX, rotY, colors) {
                idx = builder.findIndexByPosition(voxels[index].position.add(nearby));
                if (idx == -1) { // test by side
                    plane = createPlane(side, isPerFaceUV);
                    plane.position = voxels[index].position.add(position);
                    plane.rotation.x = rotX;
                    plane.rotation.y = rotY;
                    plane.setVerticesData(BABYLON.VertexBuffer.ColorKind, colors);
                    planes.push(plane);
                } else { // test by color
                    if (isTestColor) {
                        if (voxels[index].color !== builder.voxels[idx].color) {
                            plane = createPlane(side, isPerFaceUV);
                            plane.position = voxels[index].position.add(position);
                            plane.rotation.x = rotX;
                            plane.rotation.y = rotY;
                            plane.setVerticesData(BABYLON.VertexBuffer.ColorKind, colors);
                            planes.push(plane);
                        }
                    }
                }
            }

            for (let i = 0; i < voxels.length; i++) {
                colors = [];
                const rgb = hexToRgbFloat(voxels[i].color);
                for (let p = 0; p < 8; p++) { //24 verts / 3 = 8
                    colors.push(rgb.r, rgb.g, rgb.b, 1);
                }

                createSide(i, 'right', // X+
                            new BABYLON.Vector3(0.5, 0, 0),
                            new BABYLON.Vector3(1, 0, 0),
                            0, -PIH, colors);
                createSide(i, 'left', // X-
                            new BABYLON.Vector3(-0.5, 0, 0),
                            new BABYLON.Vector3(-1, 0, 0),
                            0, PIH, colors);
                createSide(i, 'top', // +Y
                            new BABYLON.Vector3(0, 0.5, 0),
                            new BABYLON.Vector3(0, 1, 0),
                            PIH, 0, colors);
                createSide(i, 'bottom', // -Y
                            new BABYLON.Vector3(0, -0.5, 0),
                            new BABYLON.Vector3(0, -1, 0),
                            -PIH, 0, colors);
                createSide(i, 'front', // Z+
                            new BABYLON.Vector3(0, 0, 0.5),
                            new BABYLON.Vector3(0, 0, 1),
                            0, Math.PI, colors);
                createSide(i, 'back', // Z-
                            new BABYLON.Vector3(0, 0, -0.5),
                            new BABYLON.Vector3(0, 0, -1),
                            0, 0, colors);
            }

            const mesh = BABYLON.Mesh.MergeMeshes(planes, true, true);
            mesh.name = name;
            
            planes = null;
            colors = null;
            return mesh;
        }

        function createPlane(side, isPerFaceUV) {
            let indices = [ 0, 1, 2, 0, 2, 3 ];
            let positions = [ -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5,  0.5, 0, -0.5,  0.5, 0 ];
            let normals = [ 0, 0, -1.0, 0, 0, -1.0, 0, 0, -1.0, 0, 0, -1.0 ];
            
            let uvs = [];
            if (isPerFaceUV) {
                uvs = [ 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0 ];
            } else {
                if (side == 'right')  uvs.push(1,1/3, 0,1/3,  0,2/3, 1,2/3);
                if (side == 'left')   uvs.push(1,1/3, 0,1/3,  0,2/3, 1,2/3);
                if (side == 'top')    uvs.push(0,1,   1,1,    1,2/3, 0,2/3);
                if (side == 'bottom') uvs.push(0,1/3, 1,1/3,  1,0,   0,0);
                if (side == 'front')  uvs.push(1,1/3, 0,1/3,  0,2/3, 1,2/3);
                if (side == 'back')   uvs.push(1,1/3, 0,1/3,  0,2/3, 1,2/3);
            }

            BABYLON.VertexData._ComputeSides(BABYLON.VertexData.FRONTSIDE, positions, indices, normals, uvs);

            const mesh = new BABYLON.Mesh('plane', scene);
            let vertexData = new BABYLON.VertexData();
            vertexData.indices = indices;
            vertexData.positions = positions;
            vertexData.normals = normals;
            vertexData.uvs = uvs;
            vertexData.applyToMesh(mesh);

            vertexData = null;
            indices = null;
            positions = null;
            normals = null;
            uvs = null;
            return mesh;
        }
    }


    // -------------------------------------------------------
    // Storage


    function Storage() {
        const storageVoxels = 'vbstore_voxels';
        const storageBakes = 'vbstore_bakes';

        this.setStorageVoxels = function() {
            localStorage.setItem(storageVoxels, builder.getData());
        }

        this.getStorageVoxels = function() {
            let data = localStorage.getItem(storageVoxels);
            if (!data) {
                ui.notification("empty storage");
                return;
            }
            builder.setData(data);
            memory.clear();
            data = null;
        }

        this.setStorageBakes = function() {
            if (bakery.meshes.length > 0) {
                const options = {
                    shouldExportNode: function(node) {
                        return bakery.meshes.includes(node);
                    }
                }
                BABYLON.GLTF2Export.GLBAsync(scene, storageBakes, options).then((glb) => {
                    const blob = glb.glTFFiles[storageBakes + ".glb"];
                    const file = new File([ blob ], "storage.glb");
                    const reader = new FileReader();
                    reader.onload = function() {
                        localStorage.setItem(storageBakes, reader.result);
                    }
                    reader.readAsDataURL(file);
                });
            } else {
                localStorage.setItem(storageBakes, 0);
            }
        }
        
        this.getStorageBakes = function() {
            let data = localStorage.getItem(storageBakes);
            if (data && data !== '0') {
                bakery.clearBakes(false);
                bakery.loadBakes(data, true);
            }
            data = null;
        }

        this.delStorage = function(name) {
            if (localStorage.getItem(name))
                localStorage.removeItem(name);
        }
    }


    // -------------------------------------------------------
    // Memory
    // TODO: infinite memory


    function Memory() {
        this.stack = [];
        this.block = -1;

        this.record = function() {
            this.stack[++this.block] = builder.getData();
            this.stack.splice(this.block + 1); // delete anything forward
        }

        this.undo = function() {
            --this.block;
            if (this.stack[this.block]) {
                builder.setData(this.stack[this.block]);
            } else {
                ++this.block;
            }
        }

        this.redo = function() {
            ++this.block;
            if (this.stack[this.block]) {
                builder.setData(this.stack[this.block]);
            } else {
                --this.block;
            }
        }

        this.clear = function() {
            this.stack = [];
            this.block = -1;
            this.record(); // init memory block 0
        }
    }


    // -------------------------------------------------------
    // Project


    function Project(scene) {
        this.newBox = function(size = 8, hex = currentColor) {
            size = (size - 1) / 2;
            let data = [];
            for (let x = -size; x <= size; x++) {
                for (let y = 0; y <= size*2; y++) {
                    for (let z = -size; z <= size; z++) {
                        data.push({
                            position: new BABYLON.Vector3(x, y, z),
                            color: hex,
                            visible: true
                        });
                    }
                }
            }
            builder.loadData(data, false, false);
            memory.clear();
            symmetry.resetAxis();
            bakery.clearBakes();
            ui.setMode(0);
            camera.frame();
            ui.domProjectName.value = 'untitled';
            data = null;
        }

        this.load = function(voxdata) {
            if (voxdata.startsWith('#')) {
                this.loadOld(voxdata); // backward compatibity
                return;
            }

            let ini = parseINI(voxdata);
            
            // [project]
            ui.domProjectName.value = ini.project.name;

            // [data.voxels]
            let voxels = ini.data.voxels.split(';').slice(0, -1);
            let data = [];
            for (let i = 0; i < voxels.length; i++) {
                const chunk = voxels[i].split(',');
                data.push({ 
                    position: new BABYLON.Vector3(
                        parseFloat(chunk[0]),
                        parseFloat(chunk[1]),
                        parseFloat(chunk[2])
                    ),
                    color: chunk[3],
                    visible: parseBool(chunk[4])
                });
            }
            ui.setMode(0);
            builder.loadData(data, false, false);
            memory.clear();
            symmetry.resetAxis();
            camera.frame();

            // [data.bakes]
            if (ini.data.bakes) {
                bakery.clearBakes(false);
                bakery.loadBakes(ini.data.bakes, false);
            } else {
                bakery.clearBakes(false);
            }

            ini = null;
            data = null;
            voxels = null;
        }

        this.save = function() {
            let data = '; Voxel Builder file format (VBX)\n\n';

            data += '[project]\n';
            data += 'name=' + ui.domProjectName.value + '\n\n';

            let line = '';
            for (let i = 0; i < builder.voxels.length; i++) {
                line += builder.voxels[i].position.x + ',' +
                        builder.voxels[i].position.y + ',' +
                        builder.voxels[i].position.z + ',' +
                        builder.voxels[i].color + ',' +
                        builder.voxels[i].visible + ';';
            }
            data += '[data]\n';
            data += 'voxels=' + line + '\n';
            line = null;

            if (bakery.meshes.length > 0) {
                const options = {
                    shouldExportNode: function(node) {
                        return bakery.meshes.includes(node);
                    }
                }
                BABYLON.GLTF2Export.GLBAsync(scene, ui.domProjectName.value, options).then((glb) => {
                    const blob = glb.glTFFiles[ui.domProjectName.value + ".glb"];
                    const file = new File([ blob ], "exported.glb");
                    const reader = new FileReader();
                    reader.onload = function() {
                        data += 'bakes=' + reader.result + '\n';
                        saveFile(data, ui.domProjectName.value + '.vbx');
                        data = null;
                    }
                    reader.readAsDataURL(file);
                });
            } else {
                saveFile(data, ui.domProjectName.value + '.vbx');
                data = null;
            }
        }

        this.loadOld = function(voxdata) { // < 3.8.9
            ui.setMode(0);
            let lines = voxdata.split('\n');
            let data = [];
            let chunk = [];
            let line = '';
            ui.domProjectName.value = 'untitled';
            for (let i = 0; i < lines.length; i++) {
                if (lines[i]) { // ignore empty lines
                    line = lines[i].replace(/\s+/g, ''); // strip whitespaces
                    if (line.startsWith('#')) {
                        ui.domProjectName.value = line.substring(1); // strip #
                    } else if (line.startsWith('data:')) {
                        bakery.clearBakes();
                        bakery.loadBakes(line, false);
                    } else {
                        chunk = line.split(',');
                        data.push({ 
                            position: new BABYLON.Vector3(
                                parseFloat(chunk[0]),
                                parseFloat(chunk[1]),
                                parseFloat(chunk[2])),
                            color: chunk[3],
                            visible: parseBool(chunk[4])
                        });
                    }
                }
            }
            if (!lines[lines.length - 1].startsWith('data:'))
                bakery.clearBakes(false); // no bakes, just clear bakery
            builder.loadData(data, false, false);
            memory.clear();
            symmetry.resetAxis();
            camera.frame();
            data = null;
            chunk = null;
            lines = null;
            voxdata = null;
        }

        this.import = function(voxdata) {
            let ini = parseINI(voxdata);
            if (!ini.data.bakes) {
                ui.notification('unable to read baked data');
                return;
            }
            bakery.loadBakes(ini.data.bakes, true);
            camera.frame();
            ini = null;
        }

        this.exportVoxels = function() {
            const options = {
                shouldExportNode: function(node) {
                    return node == builder.SPS.mesh;
                }
            }
            engine.displayLoadingUI();
            builder.SPS.mesh.material = material.createExportMaterial();
            BABYLON.GLTF2Export.GLBAsync(scene, ui.domProjectName.value, options).then((glb) => {
                glb.downloadFiles();
                builder.SPS.mesh.material.dispose();
                builder.SPS.mesh.material = material.mat_cel;
                engine.hideLoadingUI();
            });
        }

        this.exportBakes = function() {
            if (bakery.meshes.length == 0) {
                ui.notification('no baked meshes to export');
                return;
            }
            const options = {
                shouldExportNode: function(node) {
                    return bakery.meshes.includes(node);
                }
            }
            engine.displayLoadingUI();
            BABYLON.GLTF2Export.GLBAsync(scene, ui.domProjectName.value, options).then((glb) => {
                glb.downloadFiles();
                engine.hideLoadingUI();
            });
        }

        this.loadFromUrl = function(url) {
            if (url == '') return;
            fetch(url).then(
                function(response) {
                    if (response.status !== 200) {
                        ui.notification('unable to load data from url');
                        return;
                    }
                    response.text().then(function(data) {
                        project.load(data);
                    });
                }
            ).catch(function(err) {
                console.error('loadUrl', err);
            });
        }

        this.loadMagicaVoxel = function(buffer) {
            engine.displayLoadingUI();
            setTimeout(() => {
                let chunks = parseMagicaVoxel(buffer);
                if (!chunks) {
                    ui.notification('unable to load magicavoxel file');
                    return;
                }
                if (chunks[0].data.length / 4 > MAXAMOUNT)
                    ui.notification('warning: 64k voxel limit', 5000);

                let data = [];
                for (let i = 0; i < chunks[0].data.length; i += 4) {
                    const x = chunks[0].data[ i + 0 ];
                    const z = -chunks[0].data[ i + 1 ];
                    const y = chunks[0].data[ i + 2 ];
                    const c = chunks[0].data[ i + 3 ];

                    const hex = chunks[0].palette[ c ];
                    const r = ( hex >> 0 & 0xff ) / 0xff;
                    const g = ( hex >> 8 & 0xff ) / 0xff;
                    const b = ( hex >> 16 & 0xff ) / 0xff;

                    data.push({ 
                        position: new BABYLON.Vector3(x, y, z),
                        color: rgbFloatToHex(r, g, b),
                        visible: true
                    });
                }

                ui.setMode(0);
                builder.loadData(data, false, true);
                memory.clear();
                symmetry.resetAxis();
                bakery.clearBakes(false);
                camera.frame();
                data = null;
                chunks = null;
                buffer = null;
                engine.hideLoadingUI();
            }, 0);
        }
    }
    

    // -------------------------------------------------------
    // UserInterface


    function UserInterface(scene) {
        this.isShowMenuAbout = false;
        this.isShowMenuPrefs = false;
        this.isShowMenuFile = false;
        this.isShowMenuGenerator = false;
        this.isShowMenuVoxelizer = false;
        this.isShowMenuSymmetry = false;
        this.isShowMenuModel = false;
        this.isShowMenuPaint = false;
        this.isShowMenuVoxels = false;
        this.isShowMenuBakery = false;
        this.isShowMenuBakes = false;
        this.isShowMenuCamera = false;
        this.isShowMenuEnv = false;
        this.isShowMenuMaterial = false;
        this.isShowMenuTexture = false;
        this.isShowMenuRender = false;
        this.domToolbarR = document.getElementById('toolbar_R');
        this.domToolbarL = document.getElementById('toolbar_L');
        this.domToolbarC = document.getElementById('toolbar_C');
        this.domToolbarC_mem = document.getElementById('toolbar_C_mem');
        this.domModes = document.querySelectorAll('#toolbar_C li.mode');
        this.domMenuR = document.getElementsByClassName('menu_R');
        this.domMenuL = document.getElementsByClassName('menu_L');
        this.domMenuAbout = document.getElementById('menu-about');
        this.domMenuPrefs = document.getElementById('menu-prefs');
        this.domMenuFile = document.getElementById('menu-file');
        this.domMenuGenerator = document.getElementById('menu-generator');
        this.domMenuVoxelizer = document.getElementById('menu-voxelizer');
        this.domMenuSymmetry = document.getElementById('menu-symmetry');
        this.domMenuModel = document.getElementById('menu-model');
        this.domMenuPaint = document.getElementById('menu-paint');
        this.domMenuVoxels = document.getElementById('menu-voxels');
        this.domMenuBakery = document.getElementById('menu-bakery');
        this.domMenuBakes = document.getElementById('menu-bakes');
        this.domMenuCamera = document.getElementById('menu-camera');
        this.domMenuEnv = document.getElementById('menu-env');
        this.domMenuMaterial = document.getElementById('menu-material');
        this.domMenuTexture = document.getElementById('menu-texture');
        this.domMenuRender = document.getElementById('menu-render');
        this.domSymmAxis = document.getElementById('btn-symm-axis');
        this.domSymmAxis2 = document.getElementById('btn-helper-symmetry');
        this.domWorkplane = document.getElementById('input-helper-workplane');
        this.domWorkplaneBtn = document.getElementById('btn-helper-workplane');
        this.domColorPicker = document.getElementById('colorpicker');
        this.domPalette = document.getElementById('palette');
        this.domPaletteColors = document.getElementById('palette-colors');
        this.domHover = document.getElementById('hover');
        this.domMarquee = document.getElementById("marquee");
        this.domBoxToolHeight = document.getElementById('input-boxtool-height');
        this.domPipelineContrast = document.getElementById('input-pipeline-contrast');
        this.domPipelineExposure = document.getElementById('input-pipeline-exposure');
        this.domPipelineHue = document.getElementById('input-pipeline-hue');
        this.domPipelineBloom = document.getElementById('input-pipeline-bloom');
        this.domPipelineDof = document.getElementById('input-pipeline-dof');
        this.domPipelineDofDist = document.getElementById('input-pipeline-dofdist');
        this.domPipelineSharpen = document.getElementById('input-pipeline-sharpen');
        this.domPipelineChromatic = document.getElementById('input-pipeline-chromatic');
        this.domHdriToggle = document.getElementById('input-hdri-toggle');
        this.domHdriBlur = document.getElementById('input-hdri-blur');
        this.domCamFov = document.getElementById('input-camera-fov');
        this.domBakeryPerFaceUvs = document.getElementById('input-bakery-uvs');
        this.domAutoRotation = document.getElementById('input-autorotate');
        this.domMaterialAutoUpdate = document.getElementById('input-material-autoupdate');
        this.domTexturePresets = document.getElementById('texturepresets');
        this.domRoughness = document.getElementById('input-material-roughness');
        this.domMetallic = document.getElementById('input-material-metallic');
        this.domAlpha = document.getElementById('input-material-alpha');
        this.domBackgroundCheck = document.getElementById('input-env-bgcheck');
        this.domColorPickerGlobal = document.getElementById('input-color');
        this.domColorPickerBackground = document.getElementById('input-env-background');
        this.domColorPickerRenderLightColor = document.getElementById('input-env-lightcolor');
        this.domColorPickerEmissive = document.getElementById('input-material-emissive');
        this.domProjectName = document.getElementById('input-project-name');
        this.domPrefsNoIntro = document.getElementById('input-prefs-nointro');
        this.domPrefsLowEndMobile = document.getElementById('input-prefs-lowend');
        this.domAxisViewHitbox = document.getElementById('axisview-hitbox');
        this.domOrthoBtn = document.getElementById('btn-ortho');
        this.domReticle = document.getElementById('reticle');
        this.domAppIframe = document.getElementById('aiframe');
        this.domHelp = document.getElementById('help');
        this.domConfirm = document.getElementById('confirm');
        this.domConfirmBlocker = document.getElementById('confirmblocker');
        this.domNotifier = document.getElementById('notifier');
        this.domIntro = document.getElementById('intro');
        this.domInfo = document.getElementById('info').children;
        this.domLoadingScreen = document.getElementById('loadingscreen');
        const styleMenuR = 'translate(200px, 0)';
        const styleMenuL = 'translate(-200px, 0)';
        const styleMenuR_open = 'translate(-61px, 0)';
        const styleMenuL_open = 'translate(61px, 0)';
        let notificationTimer = null;
        let xOffset = 0, yOffset = 0; // hover

        this.init = function() {
            this.domColorPickerGlobal.addEventListener('input', (ev) => {
                currentColor = ui.domColorPickerGlobal.value.toUpperCase();
                uix.colorPicker.value = BABYLON.Color3.FromHexString(currentColor);
                if (MODE == 1)
                    bakery.setMaterial('albedo'); // update material
            }, false);

            this.domColorPickerEmissive.addEventListener('input', (ev) => {
                bakery.setMaterial('emissive');
            }, false);

            this.domColorPickerBackground.addEventListener('input', (ev) => {
                if (MODE == 0 || MODE == 1) {
                    scene.clearColor = BABYLON.Color4.FromHexString(ui.domColorPickerBackground.value);
                } else if (MODE == 2) {
                    scene.clearColor = BABYLON.Color4.FromHexString(ui.domColorPickerBackground.value).toLinearSpace();
                }
                scene.autoClear = ui.domBackgroundCheck.checked;
            }, false);

            this.domColorPickerRenderLightColor.addEventListener('input', (ev) => {
                updateLightColor(ui.domColorPickerRenderLightColor.value);
            }, false);

            this.domLoadingScreen.addEventListener('click', (ev) => {
                if (ui.domHelp.style.bottom == '0px') ui.toggleHelp();
                if (!this.domAppIframe.src == '') ui.closeAppIframe();
            }, false);
        }

        this.setMode = function(mode) {
            MODE = mode;

            for (let i = 0; i < viewAxes.length; i++)
                viewAxes[i].isVisible = true;

            if (mode == 0) {
                scene.clearColor = BABYLON.Color4.FromHexString(this.domColorPickerBackground.value);
                scene.lights[0].intensity = 0.4; // ambient
                scene.lights[1].getShadowGenerator().filteringQuality = BABYLON.ShadowGenerator.QUALITY_MEDIUM;
                scene.lights[1].getShadowGenerator().bias = 0.00005;
                scene.lights[1].getShadowGenerator().setDarkness(0.6);
                tool.toolSelector('camera');
                toolBakery.toolSelector('xform');
                builder.setMeshVisibility(true);
                builder.SPS.mesh.material = material.mat_cel;
                bakery.setBakesVisibility(false);
                uix.showJoysticks(false);
                pipeline.dispose();
                helper.gridPlane.isVisible = true;
                if (ui.domWorkplane.checked) {
                    uix.bindWorkplane();
                } else {
                    uix.unbindWorkplane();
                }
            } else if (mode == 1) {
                scene.clearColor = BABYLON.Color4.FromHexString(this.domColorPickerBackground.value);
                scene.lights[0].intensity = 0.2;
                scene.lights[1].getShadowGenerator().filteringQuality = BABYLON.ShadowGenerator.QUALITY_MEDIUM;
                scene.lights[1].getShadowGenerator().bias = 0.00005;
                scene.lights[1].getShadowGenerator().setDarkness(0);
                tool.toolSelector('camera');
                toolBakery.toolSelector('xform');
                builder.setMeshVisibility(false);
                bakery.setBakesVisibility(true);
                uix.showJoysticks(false);
                pipeline.dispose();
                helper.gridPlane.isVisible = true;
                helper.workPlane.isVisible = false;
                uix.unbindWorkplane();
            } else if (mode == 2) {
                scene.clearColor = BABYLON.Color4.FromHexString(this.domColorPickerBackground.value).toLinearSpace();
                scene.lights[0].intensity = 0;
                scene.lights[1].getShadowGenerator().setDarkness(0);
                tool.toolSelector('camera');
                toolBakery.toolSelector('xform');
                if (bakery.meshes.length > 0) { // RENDER bakes
                    scene.lights[1].getShadowGenerator().filteringQuality = BABYLON.ShadowGenerator.QUALITY_HIGH;
                    scene.lights[1].getShadowGenerator().bias = 0.00005;
                    builder.setMeshVisibility(false);
                    bakery.setBakesVisibility(true);
                    builder.SPS.mesh.material = material.mat_cel;
                } else { // PREVIEW voxels
                    scene.lights[1].getShadowGenerator().filteringQuality = BABYLON.ShadowGenerator.QUALITY_MEDIUM;
                    scene.lights[1].getShadowGenerator().bias = 0.0002;
                    builder.setMeshVisibility(true);
                    bakery.setBakesVisibility(false);
                    material.setPBRTexture(0);
                    material.update();
                    builder.SPS.mesh.material = material.mat_pbr;
                }
                uix.showJoysticks(isMobileDevice());
                pipeline.init();
                helper.gridPlane.isVisible = false;
                helper.workPlane.isVisible = false;
                uix.unbindWorkplane();
                for (let i = 0; i < viewAxes.length; i++)
                    viewAxes[i].isVisible = false;
            }

            scene.autoClear = this.domBackgroundCheck.checked;
            hdri.toggleSkybox(this.domHdriToggle.checked);

            if (scene.activeCamera.useAutoRotationBehavior)
                camera.toggleCameraAutoRotation();
            camera.switchCamera();

            this.setInterfaceMode();
            this.updateStatus();
            updateShadowMap();

            for (let i of this.domModes)
                i.classList.remove("mode_select");
            this.domModes[mode].classList.add("mode_select");
        }

        this.setInterfaceMode = function() {
            this.domToolbarC_mem.style.display = 'unset';
            this.domPalette.style.display = 'unset';
            this.domHover.style.display = 'unset';
            this.domPalette.style.display = 'unset';
            this.domColorPicker.style.display = 'unset';
            this.domReticle.style.display = 'none';
            this.domAxisViewHitbox.style.display = 'none';
            this.domAutoRotation.disabled = false;
            this.domOrthoBtn.disabled = false;
            this.domSymmAxis2.style.display = 'none';
            this.domWorkplaneBtn.style.display = 'none';
            uix.colorPicker.isVisible = true;
            for (let i of this.domToolbarL.children)
                i.style.display = 'unset';
            for (let i of this.domToolbarR.children)
                i.style.display = 'unset';
                
            if (MODE == 0) {
                this.domToolbarR.children[9].style.display = 'none'; // BAKES
                this.domToolbarL.children[3].style.display = 'none'; // MAT
                this.domToolbarL.children[4].style.display = 'none'; // TEX
                this.domToolbarL.children[5].style.display = 'none'; // RENDER
                this.domToolbarC_mem.children[0].onclick = storage.setStorageVoxels; // SAVE
                this.domToolbarC_mem.children[1].onclick = storage.getStorageVoxels; // LOAD
                this.domToolbarC_mem.children[2].style.display = 'inline-block'; // UNDO
                this.domToolbarC_mem.children[3].style.display = 'inline-block'; // REDO
                this.domSymmAxis2.style.display = 'unset';
                this.domWorkplaneBtn.style.display = 'unset';
            } else if (MODE == 1) {
                this.domPalette.style.display = 'none';
                this.domHover.style.display = 'none';
                this.domToolbarR.children[2].style.display = 'none'; // GENERATOR
                this.domToolbarR.children[3].style.display = 'none'; // VOXELIZER
                this.domToolbarR.children[4].style.display = 'none'; // SYMMETRY
                this.domToolbarR.children[5].style.display = 'none'; // TOOLS
                this.domToolbarR.children[6].style.display = 'none'; // PAINT
                this.domToolbarR.children[7].style.display = 'none'; // VOXELS
                this.domToolbarL.children[5].style.display = 'none'; // RENDER
                this.domToolbarC_mem.children[0].onclick = storage.setStorageBakes; // SAVE
                this.domToolbarC_mem.children[1].onclick = storage.getStorageBakes; // LOAD
                this.domToolbarC_mem.children[2].style.display = 'none'; // UNDO
                this.domToolbarC_mem.children[3].style.display = 'none'; // REDO
            } else if (MODE == 2) {
                this.domToolbarC_mem.style.display = 'none';
                this.domPalette.style.display = 'none';
                this.domColorPicker.style.display = 'none';
                this.domHover.style.display = 'none';
                this.domReticle.style.display = 'grid';
                this.domToolbarR.children[2].style.display = 'none'; // GENERATOR
                this.domToolbarR.children[3].style.display = 'none'; // VOXELIZER
                this.domToolbarR.children[4].style.display = 'none'; // SYMMETRY
                this.domToolbarR.children[5].style.display = 'none'; // TOOLS
                this.domToolbarR.children[6].style.display = 'none'; // PAINT
                this.domToolbarR.children[7].style.display = 'none'; // VOXELS
                this.domToolbarR.children[8].style.display = 'none'; // BAKERY
                this.domToolbarR.children[9].style.display = 'none'; // BAKES
                this.domToolbarL.children[3].style.display = 'none'; // MAT
                this.domToolbarL.children[4].style.display = 'none'; // TEX
                this.domAutoRotation.disabled = true;
                this.domOrthoBtn.disabled = true;
                uix.colorPicker.isVisible = false;
                if (isMobileDevice()) // allow to frame camera (joysticks prevent access to axisview)
                    this.domAxisViewHitbox.style.display = 'unset';
            }

            if (scene.activeCamera.mode == BABYLON.Camera.PERSPECTIVE_CAMERA)
                this.domOrthoBtn.innerHTML = 'Perspective';
            if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA)
                this.domOrthoBtn.innerHTML = 'Orthographic';
        }

        this.toggleMenuAbout = function() {
            this.isShowMenuAbout = !this.isShowMenuAbout;
            this.switchMenus(this.domMenuAbout, 'right', this.isShowMenuAbout);
        }
        this.toggleMenuPrefs = function() {
            this.isShowMenuPrefs = !this.isShowMenuPrefs;
            this.switchMenus(this.domMenuPrefs, 'right', this.isShowMenuPrefs);
        }
        this.toggleMenuFile = function() {
            this.isShowMenuFile = !this.isShowMenuFile;
            this.switchMenus(this.domMenuFile, 'right', this.isShowMenuFile);
        }
        this.toggleMenuGenerator = function() {
            this.isShowMenuGenerator = !this.isShowMenuGenerator;
            this.switchMenus(this.domMenuGenerator, 'right', this.isShowMenuGenerator);
        }
        this.toggleMenuVoxelizer = function() {
            this.isShowMenuVoxelizer = !this.isShowMenuVoxelizer;
            this.switchMenus(this.domMenuVoxelizer, 'right', this.isShowMenuVoxelizer);
        }
        this.toggleMenuSymmetry = function() {
            this.isShowMenuSymmetry = !this.isShowMenuSymmetry;
            this.switchMenus(this.domMenuSymmetry, 'right', this.isShowMenuSymmetry);
        }
        this.toggleMenuModel = function() {
            this.isShowMenuModel = !this.isShowMenuModel;
            this.switchMenus(this.domMenuModel, 'right', this.isShowMenuModel);
        }
        this.toggleMenuPaint = function() {
            this.isShowMenuPaint = !this.isShowMenuPaint;
            this.switchMenus(this.domMenuPaint, 'right', this.isShowMenuPaint);
        }
        this.toggleMenuVoxels = function() {
            this.isShowMenuVoxels = !this.isShowMenuVoxels;
            this.switchMenus(this.domMenuVoxels, 'right', this.isShowMenuVoxels);
        }
        this.toggleMenuBakery = function() {
            this.isShowMenuBakery = !this.isShowMenuBakery;
            this.switchMenus(this.domMenuBakery, 'right', this.isShowMenuBakery);
        }
        this.toggleMenuBakes = function() {
            this.isShowMenuBakes = !this.isShowMenuBakes;
            this.switchMenus(this.domMenuBakes, 'right', this.isShowMenuBakes);
        }
        this.toggleMenuCamera = function() {
            this.isShowMenuCamera = !this.isShowMenuCamera;
            this.switchMenus(this.domMenuCamera, 'left', this.isShowMenuCamera);
        }
        this.toggleMenuEnv = function() {
            this.isShowMenuEnv = !this.isShowMenuEnv;
            this.switchMenus(this.domMenuEnv, 'left', this.isShowMenuEnv);
        }
        this.toggleMenuMaterial = function() {
            this.isShowMenuMaterial = !this.isShowMenuMaterial;
            this.switchMenus(this.domMenuMaterial, 'left', this.isShowMenuMaterial);
        }
        this.toggleMenuTexture = function() {
            this.isShowMenuTexture = !this.isShowMenuTexture;
            this.switchMenus(this.domMenuTexture, 'left', this.isShowMenuTexture);
        }
        this.toggleMenuRender = function() {
            this.isShowMenuRender = !this.isShowMenuRender;
            this.switchMenus(this.domMenuRender, 'left', this.isShowMenuRender);
        }

        this.clearAllMenus = function(side, exclude = null) {
            if (side == 'right' || side == 'both') {
                if (exclude !== this.domMenuAbout) {
                    this.domMenuAbout.style.transform = styleMenuR;
                    this.isShowMenuAbout = false;
                }
                if (exclude !== this.domMenuPrefs) {
                    this.domMenuPrefs.style.transform = styleMenuR;
                    this.isShowMenuPrefs = false;
                }
                if (exclude !== this.domMenuFile) {
                    this.domMenuFile.style.transform = styleMenuR;
                    this.isShowMenuFile = false;
                }
                if (exclude !== this.domMenuGenerator) {
                    this.domMenuGenerator.style.transform = styleMenuR;
                    this.isShowMenuGenerator = false;
                }
                if (exclude !== this.domMenuVoxelizer) {
                    this.domMenuVoxelizer.style.transform = styleMenuR;
                    this.isShowMenuVoxelizer = false;
                }
                if (exclude !== this.domMenuBakery) {
                    this.domMenuBakery.style.transform = styleMenuR;
                    this.isShowMenuBakery = false;
                }
                if (exclude !== this.domMenuBakes) {
                    this.domMenuBakes.style.transform = styleMenuR;
                    this.isShowMenuBakes = false;
                }
                if (exclude !== this.domMenuSymmetry) {
                    this.domMenuSymmetry.style.transform = styleMenuR;
                    this.isShowMenuSymmetry = false;
                }
                if (exclude !== this.domMenuModel) {
                    this.domMenuModel.style.transform = styleMenuR;
                    this.isShowMenuModel = false;
                }
                if (exclude !== this.domMenuPaint) {
                    this.domMenuPaint.style.transform = styleMenuR;
                    this.isShowMenuPaint = false;
                }
                if (exclude !== this.domMenuVoxels) {
                    this.domMenuVoxels.style.transform = styleMenuR;
                    this.isShowMenuVoxels = false;
                }
            }
            if (side == 'left' || side == 'both') {
                if (exclude !== this.domMenuCamera) {
                    this.domMenuCamera.style.transform = styleMenuL;
                    this.isShowMenuCamera = false;
                }
                if (exclude !== this.domMenuEnv) {
                    this.domMenuEnv.style.transform = styleMenuL;
                    this.isShowMenuEnv = false;
                }
                if (exclude !== this.domMenuMaterial) {
                    this.domMenuMaterial.style.transform = styleMenuL;
                    this.isShowMenuMaterial = false;
                }
                if (exclude !== this.domMenuTexture) {
                    this.domMenuTexture.style.transform = styleMenuL;
                    this.isShowMenuTexture = false;
                }
                if (exclude !== this.domMenuRender) {
                    this.domMenuRender.style.transform = styleMenuL;
                    this.isShowMenuRender = false;
                }
            }
        }

        this.switchMenus = function(elem, side, isEnabled) {
            this.clearAllMenus(side, elem);
            if (isEnabled) {
                if (side == 'right') elem.style.transform = styleMenuR_open;
                if (side == 'left')  elem.style.transform = styleMenuL_open;
            } else {
                if (side == 'right') elem.style.transform = styleMenuR;
                if (side == 'left')  elem.style.transform = styleMenuL;
            }
        }

        this.updateStatus = function() {
            if (MODE == 0) {
                this.domInfo[1].innerHTML = builder.voxels.length + ' VOX';
                this.domInfo[2].innerHTML = palette.uniqueColors.length + ' COL';
            } else if (MODE == 1) {
                this.domInfo[1].innerHTML = bakery.meshes.length + ' MSH';
                this.domInfo[2].innerHTML = scene.getTotalVertices() + ' VTX';
            } else if (MODE == 2) {
                ui.domInfo[1].innerHTML = 'FOV ' + camera.camera2.fov;
                if (bakery.meshes.length > 0) {
                    this.domInfo[2].innerHTML = 'FINAL';
                } else {
                    this.domInfo[2].innerHTML = 'PREVIEW';
                }
            }
        }

        this.notification = function(txt, ms = 3000) {
            if (this.domNotifier.style.display == 'unset') { // prevent overdraw
                clearTimeout(notificationTimer);
            };
            this.domNotifier.innerHTML = txt.toUpperCase();
            this.domNotifier.style.display = 'unset';
            this.domNotifier.style.marginLeft = -(this.domNotifier.getBoundingClientRect().width/2) + 'px';
            notificationTimer = setTimeout(() => {
                ui.domNotifier.style.display = 'none';
            }, ms);
        }

        this.openAppIframe = function(name) {
            engine.displayLoadingUI();
            this.resizeAppIframe();
            this.domAppIframe.parentElement.style.display = 'unset';
            switch (name) {
                case 'asset-viewer':
                    this.domAppIframe.src = 'https://nimadez.github.io/voxel-builder/apps/asset-viewer/';
                    break;
                case 'pixel-monk':
                    this.domAppIframe.src = 'https://nimadez.github.io/voxel-builder/apps/pixel-monk/';
                    break;
            }
        }

        this.closeAppIframe = function() {
            this.domAppIframe.src = '';
            this.domAppIframe.parentElement.style.display = 'none';
            engine.hideLoadingUI();
        }

        this.resizeAppIframe = function() {
            const width = canvas.width / 1;
            const height = canvas.height / 1.1;
            this.domAppIframe.parentElement.style.width = width + 'px';
            this.domAppIframe.parentElement.style.height = height + 'px';
            this.domAppIframe.parentElement.style.marginLeft = -(width/2) + 'px';
            this.domAppIframe.parentElement.style.marginTop = -(height/2) + 'px';
            this.domAppIframe.style.width = width + 'px';
            this.domAppIframe.style.height = height + 'px';
        }

        this.toggleHelp = function() {
            if (ui.domHelp.style.bottom == '0px') {
                ui.domHelp.style.bottom = '-1000px';
                engine.hideLoadingUI();
            } else {
                ui.domHelp.style.bottom = '0px';
                engine.displayLoadingUI();
            }
        }

        this.showConfirm = async function(title) {
            ui.domConfirmBlocker.style.display = 'unset';
            ui.domConfirm.style.display = 'unset';
            ui.domConfirm.children[0].innerHTML = title;
            return new Promise((resolve) => {
                ui.domConfirm.children[1].onclick = (ev) => {
                    ui.domConfirmBlocker.style.display = 'none';
                    ui.domConfirm.style.display = 'none';
                    resolve(false);
                };
                ui.domConfirm.children[2].onclick = (ev) => {
                    ui.domConfirmBlocker.style.display = 'none';
                    ui.domConfirm.style.display = 'none';
                    resolve(true);
                };
            });
        }

        this.toggleDebugMode = function() {
            if (scene.debugLayer.isVisible()) {
                this.domToolbarL.style.display = 'unset';
                this.domToolbarR.style.display = 'unset';
                if (MODE == 0) {
                    this.domToolbarC_mem.style.display = 'unset';
                    this.domPalette.style.display = 'unset';
                }
                scene.debugLayer.hide();
            } else {
                this.clearAllMenus('both');
                this.domToolbarL.style.display = 'none';
                this.domToolbarR.style.display = 'none';
                this.domToolbarC_mem.style.display = 'none';
                this.domPalette.style.display = 'none';
                scene.debugLayer.show();
            }
        }

        this.dragElement = function(elem) {
            let active = false;
            let currentX, currentY, initialX, initialY;
            // prevent fast-dragging problem with background elements
            document.body.addEventListener("mousedown", dragStart, false);
            document.body.addEventListener("mouseup", dragEnd, false);
            document.body.addEventListener("mousemove", drag, false);
            document.body.addEventListener("touchstart", dragStart, false);
            document.body.addEventListener("touchend", dragEnd, false);
            document.body.addEventListener("touchmove", drag, false);
            function dragStart(e) {
                if (e.type === "touchstart") {
                    initialX = e.touches[0].clientX - xOffset;
                    initialY = e.touches[0].clientY - yOffset;
                } else {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                }
                if (e.target === elem) active = true;
            }
            function dragEnd(e) {
                initialX = currentX;
                initialY = currentY;
                active = false;
                document.body.removeEventListener("mousedown", dragStart, false);
                document.body.removeEventListener("mouseup", dragEnd, false);
                document.body.removeEventListener("mousemove", drag, false);
                document.body.removeEventListener("touchstart", dragStart, false);
                document.body.removeEventListener("touchend", dragEnd, false);
                document.body.removeEventListener("touchmove", drag, false);
            }
            function drag(e) {
                if (active) {
                    if (e.type === "touchmove") {
                        currentX = e.touches[0].clientX - initialX;
                        currentY = e.touches[0].clientY - initialY;
                    } else {
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                    }
                    xOffset = currentX;
                    yOffset = currentY;
                    setTranslate(currentX, currentY, elem.parentElement);
                }
            }
            function setTranslate(xPos, yPos, el) {
                el.style.transform = "translate3d(" + xPos + "px, " + yPos + "px, 0)";
            }
        }

        this.init();
    }


    // -------------------------------------------------------
    // UserInterfaceAdvanced


    function UserInterfaceAdvanced(scene) {
        this.advancedTexture = null;
        this.utilLayer = null;
        this.colorPicker = undefined;
        this.gizmo = null;
        this.joysticks = []; // [left, right]
        this.workplaneGizmos = [];

        this.init = function() {
            this.advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI", {}, scene);
            this.utilLayer = new BABYLON.UtilityLayerRenderer(scene);
            this.utilLayer.utilityLayerScene.autoClearDepthAndStencil = true;
            this.createAdvancedColorPicker();
            this.initJoysticks();
        }

        this.createAdvancedColorPicker = function() {
            const panel = new BABYLON.GUI.StackPanel();
            panel.width = "115px";
            panel.height = "105px";
            panel.isVertical = true;
            panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            this.advancedTexture.addControl(panel);  

            this.colorPicker = new BABYLON.GUI.ColorPicker();
            this.colorPicker.value = BABYLON.Color3.FromHexString(currentColor);
            this.colorPicker.height = "100px";
            this.colorPicker.width = "100px";
            this.colorPicker.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            this.colorPicker.verticalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_TOP;
            this.colorPicker.onValueChangedObservable.add(function(value) { //color3
                currentColor = value.toHexString();
                ui.domColorPickerGlobal.value = currentColor;
                
                if (MODE == 1) // update material
                    bakery.setMaterial('albedo');
            });
            panel.addControl(this.colorPicker);
        }

        this.bindGizmo = function(meshes) {
            this.unbindGizmo();
            this.gizmo = new BABYLON.GizmoManager(scene, 3, new BABYLON.UtilityLayerRenderer(scene));
            this.gizmo.positionGizmoEnabled = true;
            this.gizmo.rotationGizmoEnabled = true;
            this.gizmo.scaleGizmoEnabled = false;
            this.gizmo.usePointerToAttachGizmos = true;
            this.gizmo.clearGizmoOnEmptyPointerEvent = false; // handled manually on pointer events

            this.gizmo.gizmos.positionGizmo.scaleRatio = 0.8;
            this.gizmo.gizmos.positionGizmo.snapDistance  = 0.5;
            this.gizmo.gizmos.positionGizmo.planarGizmoEnabled = false;
            this.gizmo.gizmos.positionGizmo.updateGizmoRotationToMatchAttachedMesh = true;
            [this.gizmo.gizmos.positionGizmo.xGizmo,
             this.gizmo.gizmos.positionGizmo.yGizmo,
             this.gizmo.gizmos.positionGizmo.zGizmo].forEach((gizmo) => {
                gizmo.dragBehavior.onDragEndObservable.add(() => {
                    updateShadowMap();
                });
            });
            
            this.gizmo.gizmos.rotationGizmo.scaleRatio = 0.4;
            this.gizmo.gizmos.rotationGizmo.snapDistance = Math.PI / 8;
            this.gizmo.gizmos.rotationGizmo.updateGizmoRotationToMatchAttachedMesh = false;
            [this.gizmo.gizmos.rotationGizmo.xGizmo,
             this.gizmo.gizmos.rotationGizmo.yGizmo,
             this.gizmo.gizmos.rotationGizmo.zGizmo].forEach((gizmo) => {
                gizmo.dragBehavior.onDragEndObservable.add(() => {
                    updateShadowMap();
                });
            });

            this.gizmo.attachableMeshes = meshes;
            this.gizmo.onAttachedToMeshObservable.add((mesh) => {
                toolBakery.onGizmoAttached(mesh);
            });
        }

        this.unbindGizmo = function() {
            if (this.gizmo) {
                this.gizmo.dispose();
                this.gizmo = null;
            }
        }

        this.bindWorkplane = function() {
            helper.workPlane.isVisible = true;
            this.workplaneGizmos[0] = new BABYLON.AxisDragGizmo(BABYLON.Axis.X, new BABYLON.Color3(1,0,0), this.utilLayer, undefined, 5);
            this.workplaneGizmos[0].scaleRatio = 0.6;
            this.workplaneGizmos[0].snapDistance = 1;
            this.workplaneGizmos[0].attachedMesh = helper.workPlane;
            this.workplaneGizmos[0].updateGizmoRotationToMatchAttachedMesh = false;
            this.workplaneGizmos[0].dragBehavior.onDragStartObservable.add(() => {
                tool.toolSelector('camera');
                helper.setWorkPlane(BABYLON.Axis.X);
                helper.workPlane.visibility = 0.8;
            });
            this.workplaneGizmos[0].dragBehavior.onDragEndObservable.add(() => {
                helper.workPlane.visibility = 0.3;
            });
            this.workplaneGizmos[1] = new BABYLON.AxisDragGizmo(BABYLON.Axis.Y, new BABYLON.Color3(0,1,0), this.utilLayer, undefined, 5);
            this.workplaneGizmos[1].scaleRatio = 0.6;
            this.workplaneGizmos[1].snapDistance = 1;
            this.workplaneGizmos[1].attachedMesh = helper.workPlane;
            this.workplaneGizmos[1].updateGizmoRotationToMatchAttachedMesh = false;
            this.workplaneGizmos[1].dragBehavior.onDragStartObservable.add(() => {
                tool.toolSelector('camera');
                helper.setWorkPlane(BABYLON.Axis.Y);
                helper.workPlane.visibility = 0.8;
            });
            this.workplaneGizmos[1].dragBehavior.onDragEndObservable.add(() => {
                helper.workPlane.visibility = 0.3;
            });
            this.workplaneGizmos[2] = new BABYLON.AxisDragGizmo(BABYLON.Axis.Z, new BABYLON.Color3(0,0,1), this.utilLayer, undefined, 5);
            this.workplaneGizmos[2].scaleRatio = 0.6;
            this.workplaneGizmos[2].snapDistance = 1;
            this.workplaneGizmos[2].attachedMesh = helper.workPlane;
            this.workplaneGizmos[2].updateGizmoRotationToMatchAttachedMesh = false;
            this.workplaneGizmos[2].dragBehavior.onDragStartObservable.add(() => {
                tool.toolSelector('camera');
                helper.setWorkPlane(BABYLON.Axis.Z);
                helper.workPlane.visibility = 0.8;
            });
            this.workplaneGizmos[2].dragBehavior.onDragEndObservable.add(() => {
                helper.workPlane.visibility = 0.3;
            });

            this.workplaneGizmos[3] = new BABYLON.AxisScaleGizmo(BABYLON.Axis.X, new BABYLON.Color3(1,1,0), this.utilLayer, undefined, 5);
            this.workplaneGizmos[3].scaleRatio = -0.3;
            this.workplaneGizmos[3].attachedMesh = helper.workPlane;
            this.workplaneGizmos[3].updateGizmoRotationToMatchAttachedMesh = false;
            this.workplaneGizmos[3].dragBehavior.onDragStartObservable.add(() => {
                uix.workplaneGizmos[3].dragBehavior.releaseDrag();
                tool.toolSelector('camera');
                helper.resetWorkplane(BABYLON.Axis.X);
            });
            this.workplaneGizmos[4] = new BABYLON.AxisScaleGizmo(BABYLON.Axis.Y, new BABYLON.Color3(1,1,0), this.utilLayer, undefined, 5);
            this.workplaneGizmos[4].scaleRatio = -0.3;
            this.workplaneGizmos[4].attachedMesh = helper.workPlane;
            this.workplaneGizmos[4].updateGizmoRotationToMatchAttachedMesh = false;
            this.workplaneGizmos[4].dragBehavior.onDragStartObservable.add(() => {
                uix.workplaneGizmos[4].dragBehavior.releaseDrag();
                tool.toolSelector('camera');
                helper.resetWorkplane(BABYLON.Axis.Y);
            });
            this.workplaneGizmos[5] = new BABYLON.AxisScaleGizmo(BABYLON.Axis.Z, new BABYLON.Color3(1,1,0), this.utilLayer, undefined, 5);
            this.workplaneGizmos[5].scaleRatio = -0.3;
            this.workplaneGizmos[5].attachedMesh = helper.workPlane;
            this.workplaneGizmos[5].updateGizmoRotationToMatchAttachedMesh = false;
            this.workplaneGizmos[5].dragBehavior.onDragStartObservable.add(() => {
                uix.workplaneGizmos[5].dragBehavior.releaseDrag();
                tool.toolSelector('camera');
                helper.resetWorkplane(BABYLON.Axis.Z);
            });
        }

        this.unbindWorkplane = function() {
            helper.workPlane.isVisible = false;
            if (this.workplaneGizmos.length > 0) {
                for (let i = 0; i < this.workplaneGizmos.length; i++)
                    this.workplaneGizmos[i].dispose();
            }
            this.workplaneGizmos = [];
        }

        this.initJoysticks = function() { // freeCameraVirtualJoystickInput.ts
            this.joysticks[0] = new BABYLON.VirtualJoystick(true);
            this.joysticks[0].setAxisForUpDown(BABYLON.JoystickAxis.Z);
            this.joysticks[0].setAxisForLeftRight(BABYLON.JoystickAxis.X);
            this.joysticks[0].setJoystickSensibility(0.15);
            this.joysticks[0].setJoystickColor("#7984A040");
            this.joysticks[0].reverseLeftRight = true; // using right-handed system
            this.joysticks[1] = new BABYLON.VirtualJoystick(false);
            this.joysticks[1].setAxisForUpDown(BABYLON.JoystickAxis.X);
            this.joysticks[1].setAxisForLeftRight(BABYLON.JoystickAxis.Y);
            this.joysticks[1].setJoystickSensibility(0.015);
            this.joysticks[1].setJoystickColor("#7984A040");
            this.joysticks[1].reverseUpDown = true;
            this.joysticks[1].reverseLeftRight = true;
            //this.joysticks[0].puckSize = 5; // introduce artifacts,
            //this.joysticks[0].containerSize = 50; // canvas clear issue
            BABYLON.VirtualJoystick.Canvas.style.zIndex = "-1"; // initialize
            BABYLON.VirtualJoystick.Canvas.style.background = "none";

            scene.onBeforeRenderObservable.add(() => {
                if (MODE == 2 && this.joysticks[0]) {
                    const speed = camera.camera2._computeLocalCameraSpeed() * 50;
                    const cameraTransform = BABYLON.Matrix.RotationYawPitchRoll(
                        camera.camera2.rotation.y, camera.camera2.rotation.x, 0);
                    const deltaTransform = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(
                            this.joysticks[0].deltaPosition.x * speed,
                            this.joysticks[0].deltaPosition.y * speed,
                            this.joysticks[0].deltaPosition.z * speed),
                            cameraTransform);
                            
                    camera.camera2.cameraDirection = camera.camera2.cameraDirection.add(deltaTransform);
                    camera.camera2.cameraRotation = camera.camera2.cameraRotation.addVector3(this.joysticks[1].deltaPosition);

                    if (!this.joysticks[0].pressed)
                        this.joysticks[0].deltaPosition = this.joysticks[0].deltaPosition.scale(0.9);
                    if (!this.joysticks[1].pressed)
                        this.joysticks[1].deltaPosition = this.joysticks[1].deltaPosition.scale(0.9);
                }
            });
        }

        this.showJoysticks = function(isVisible) {
            if (isVisible) {
                BABYLON.VirtualJoystick.Canvas.style.zIndex = "5";
            } else {
                BABYLON.VirtualJoystick.Canvas.style.zIndex = "-1";
            }
        }

        this.toggleJoysticks = function() {
            if (BABYLON.VirtualJoystick.Canvas.style.zIndex == "-1") {
                BABYLON.VirtualJoystick.Canvas.style.zIndex = "5";
            } else {
                BABYLON.VirtualJoystick.Canvas.style.zIndex = "-1";
            }
        }

        this.init();
    }


    // -------------------------------------------------------
    // Preferences
    

    function Preferences() {
        this.isNoIntro = false;

        this.init = function() {
            this.isNoIntro = parseBool(localStorage.getItem('vbp_nointro'));

            if (this.isNoIntro) {                
                ui.domPrefsNoIntro.checked = true;
            } else {
                ui.domPrefsNoIntro.checked = false;
                ui.domIntro.style.opacity = 1;
                setTimeout(() => {
                    ui.domIntro.style.opacity = 0;
                    setTimeout(() => {
                        ui.domIntro.style.display = 'none';
                    }, 1000);
                }, 5000);
            }
        }

        this.setNoIntro = function(isEnabled) {
            localStorage.setItem('vbp_nointro', isEnabled);
        }
    }


    // -------------------------------------------------------
    // Events


    scene.onPointerObservable.add((pInfo) => {
        switch (pInfo.type) {
            case BABYLON.PointerEventTypes.POINTERDOWN:
                if (MODE == 0) tool.handleToolDown(pInfo.event);
                if (MODE == 1) toolBakery.onToolDown();
                break;
            case BABYLON.PointerEventTypes.POINTERMOVE:
                if (MODE == 0) tool.handleToolMove(pInfo.event);
                if (MODE == 1) toolBakery.onToolMove();
                break;
            case BABYLON.PointerEventTypes.POINTERUP:
                if (MODE == 0) tool.handleToolUp(pInfo.event);
                if (MODE == 1) toolBakery.onToolUp();
                break;
            case BABYLON.PointerEventTypes.POINTERWHEEL:
                if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA)
                    camera.setOrthoZoom();
                break;
        }
    });

    canvas.addEventListener("touchmove", function(ev) {
        if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA)
            camera.setOrthoZoom();
    }, false);

    canvas.addEventListener("keyup", function (ev) {
        //console.log(ev.key);
        switch (ev.key) {
            case ' ': // space
                if (MODE == 0) tool.toolSelector('camera');
                break;
            case 'a':
                if (MODE == 0) tool.toolSelector('add');
                break;
            case 'b':
                if (MODE == 0) tool.toolSelector('boxadd');
                break;
            case 'r':
                if (MODE == 0) tool.toolSelector('remove');
                break;
            case 't':
                if (MODE == 0) tool.toolSelector('transform');
                break;
            case 'p':
                if (MODE == 0) tool.toolSelector('paint');
                break;
            case 'b':
                if (MODE == 0) tool.toolSelector('bucket');
                break;
            case 'e':
                if (MODE == 0) tool.toolSelector('eyedrop');
                break;
            case 's':
                if (MODE == 0) symmetry.switchAxis();
                break;
            case 'w':
                if (MODE == 0) helper.toggleWorkplane();
                break;
            case 'c':
                if (MODE == 1) bakery.cloneSelected();
                break;
            case 'Delete':
                if (MODE == 1) bakery.deleteSelected();
                break;
            case 'f':
                camera.frame();
                break;
            case 'o':
                ui.toggleDebugMode();
                break;
        }
        // memory
        if (MODE == 0) {
            if (ev.ctrlKey && ev.key === 'z') memory.undo();
            if (ev.ctrlKey && ev.key === 'x') memory.redo();
        }
    }, false);

    canvas.addEventListener("keydown", function (ev) {
        if (MODE == 2) {
            if (ev.shiftKey) { // speed up
                camera.speedUp();
            }
        }
    }, false);

    function fileHandler(file) {
        const ext = file.name.split('.').pop().toLowerCase(); //ext|exts
        const url = URL.createObjectURL(file);
        const reader = new FileReader();
        reader.onload = function() {
            if (ext === 'vbx') project.load(reader.result);
            if (ext === 'obj') voxelizer.importMesh(url);
            if (ext === 'vox') project.loadMagicaVoxel(reader.result);
            if (ext === 'hdr') hdri.loadHDR(url);
            if (['jpg','png','svg'].includes(ext)) voxelizer.voxelize2D(reader.result);
            URL.revokeObjectURL(url);
        }
        if (ext === 'vbx') {
            reader.readAsText(file);
        } else if (ext === 'vox') {
            reader.readAsArrayBuffer(file);
        } else {
            reader.readAsDataURL(file);
        }
    }

    function fileHandlerNoDrop(file) {
        const ext = file.name.split('.').pop().toLowerCase(); //ext|exts
        const url = URL.createObjectURL(file);
        const reader = new FileReader();
        reader.onload = function() {
            if (ext === 'vbx') project.import(reader.result);
            if (['jpg','png'].includes(ext)) material.addTexture(reader.result);
            URL.revokeObjectURL(url);
        }
        if (ext === 'vbx') {
            reader.readAsText(file);
        } else {
            reader.readAsDataURL(file);
        }
    }

    function dropHandler(ev) {
        ev.preventDefault();
        if (ev.dataTransfer && ev.dataTransfer.files.length !== 0)
            fileHandler(ev.dataTransfer.files[0]);
    }
    function dragHandler(ev) {
        ev.preventDefault();
    }
    function dragLeaveHandler(ev) {
        ev.preventDefault();
    }

    document.getElementById('openfile_vbx').addEventListener("change", function (ev) {
        if (ev.target.files.length > 0)
            fileHandler(ev.target.files[0]);
    }, false);

    document.getElementById('openfile_vbx_imp').addEventListener("change", function (ev) {
        if (ev.target.files.length > 0)
            fileHandlerNoDrop(ev.target.files[0]);
    }, false);

    document.getElementById('openfile_vox').addEventListener("change", function (ev) {
        if (ev.target.files.length > 0)
            fileHandler(ev.target.files[0]);
    }, false);

    document.getElementById('openfile_obj').addEventListener("change", function (ev) {
        if (ev.target.files.length > 0)
            fileHandler(ev.target.files[0]);
    }, false);

    document.getElementById('openfile_glb').addEventListener("change", function (ev) {
        if (ev.target.files.length > 0)
            fileHandler(ev.target.files[0]);
    }, false);

    document.getElementById('openfile_img').addEventListener("change", function (ev) {
        if (ev.target.files.length > 0)
            fileHandler(ev.target.files[0]);
    }, false);

    document.getElementById('openfile_tex').addEventListener("change", function (ev) {
        if (ev.target.files.length > 0)
        fileHandlerNoDrop(ev.target.files[0]);
    }, false);

    document.getElementById('openfile_hdr').addEventListener("change", function (ev) {
        if (ev.target.files.length > 0)
            fileHandler(ev.target.files[0]);
    }, false);
    
    window.addEventListener("resize", function (ev) { 
        engine.resize(true);
        updateAxisViewViewport();
        if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA)
            camera.setOrthoZoom();
        ui.resizeAppIframe();
        palette.create();
    }, false);


    // -------------------------------------------------------
    // Utils


    function CustomLoadingScreen() {
        CustomLoadingScreen.prototype.displayLoadingUI = function() {
            document.getElementById('loadingscreen').style.display = 'unset';
        }
        CustomLoadingScreen.prototype.hideLoadingUI = function() {
            document.getElementById('loadingscreen').style.display = 'none';
        }
    }
    
    const easingFunction = new BABYLON.CubicEase();
    easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
    function animator(target, property, from, to, fps=10, frames=10, callback=null) {
        BABYLON.Animation.CreateAndStartAnimation('animator',
            target, property, fps, frames, from, to, 0, easingFunction, callback);
    }

    function updateShadowMap() {
        scene.lights[1].getShadowGenerator().getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    }

    function updateViewport(w, h, bottom, right) {
        return new BABYLON.Viewport(1 - (w + right) / canvas.width, 1 - (bottom + canvas.height) / canvas.height,   w / canvas.width, h / canvas.height);
    }

    function updateAxisViewViewport() {
        sceneAxisView.activeCamera.viewport = updateViewport(100, 100, 5, -5);
    }

    function setLightPositionByAngle(light, angle, distance, height) {
        light.position = new BABYLON.Vector3(
            Math.cos(angle * Math.PI / 180) * distance,
            height,
            Math.sin(angle * Math.PI / 180) * distance);
        light.setDirectionToTarget(BABYLON.Vector3.Zero());
    }

    function updateLightAngles(value) {
        setLightPositionByAngle(scene.lights[1], parseInt(value), 50, 100);
        updateShadowMap();
    }

    function updateLightIntensity(value) {
        scene.lights[1].intensity = parseFloat(value);
    }

    function updateLightColor(hex) {
        scene.lights[1].diffuse = BABYLON.Color3.FromHexString(hex);
    }

    function enableShadows(isEnabled) {
        scene.getNodeByName("shadowcatcher").isVisible = isEnabled;
        scene.lights[1].shadowEnabled = isEnabled;
        if (MODE == 0) {
            builder.createSPS();
        }
    }

    function getMeshSize(bounds) {
        const size = new BABYLON.Vector3();
        size.x = Math.abs(bounds.minimum.x - bounds.maximum.x);
        size.y = Math.abs(bounds.minimum.y - bounds.maximum.y);
        size.z = Math.abs(bounds.minimum.z - bounds.maximum.z);
        return size;
    }

    function normalizeMesh(mesh, scale) {
        const bounds = mesh.getBoundingInfo();
        const size = getMeshSize(bounds);
        // normalize scale
        const scaleFactor = Math.min(scale / size.x, scale / size.y, scale / size.z);
        let scaleMatrix = BABYLON.Matrix.Scaling(scaleFactor, scaleFactor, scaleFactor);
        // center mesh and drop to floor
        const nX = -bounds.maximum.x + (size.x / 2);
        const nY = (size.y / 2) - bounds.boundingBox.center.y;
        const nZ = -bounds.maximum.z + (size.z / 2);
        let transMatrix = BABYLON.Matrix.Translation(nX, nY, nZ);
        // bake matrices
        let matrix = transMatrix.multiply(scaleMatrix);
        mesh.bakeTransformIntoVertices(matrix);
        scaleMatrix = null;
        transMatrix = null;
        matrix = null;
    }

    function resetPivot(mesh) {
        const center = mesh.getBoundingInfo().boundingBox.centerWorld;
        mesh.setPivotMatrix(BABYLON.Matrix.Translation(-center.x, -center.y, -center.z), false);
        mesh.bakeCurrentTransformIntoVertices();
        mesh.setPivotMatrix(BABYLON.Matrix.Identity());
        mesh.position = center;
        mesh.refreshBoundingInfo();
    }

    function createScreenshot(scale = 3) {
        if (isMobileDevice()) scale = 2;
        const canvasWidth = canvas.width;   // take shot twice larger
        const canvasHeight = canvas.height; // to improve pixel density
        engine.setSize(canvasWidth * scale, canvasHeight * scale);
        isRenderAxisView = false;
        uix.colorPicker.isVisible = false;
        BABYLON.ScreenshotTools.CreateScreenshotWithResizeAsync(engine,
            scene.activeCamera, canvasWidth * scale, canvasHeight * scale).then((data) => {
                isRenderAxisView = true;
                if (MODE !== 2)
                    uix.colorPicker.isVisible = true;
                engine.setSize(canvasWidth, canvasHeight);
        });
    }

    function clearCache() {
        engine.clearInternalTexturesCache();
        scene.cleanCachedTextureBuffer();
        BABYLON.Tools.ClearLogCache();
        memory.clear();
        ui.notification('cache cleared');
    }

    function downloadFile(txt, filename) {
        const blob = new Blob([ txt ], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }

    async function saveFile(txt, filename) { // to show a file dialog in Chrome
        if (isChrome() && !isElectron() && !isMobileDevice()) {
            try {
                const blob = new Blob([ txt ], { type: "text/plain" });
                const fileHandle = await self.showSaveFilePicker({
                    suggestedName: filename,
                    types: [ { description: "File" } ]
                });
                const writeFile = async (fileHandle, contents) => {
                    const writable = await fileHandle.createWritable();
                    await writable.write(contents);
                    await writable.close();
                };
                writeFile(fileHandle, blob).then(() => {
                    //
                });
            } catch (err) {
                // canceled
            }
        } else { // showSaveFilePicker browser support is limited
            downloadFile(txt, filename);
        }
    }

    function toggleFullscreen() {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            document.body.requestFullscreen();
        }
    }

    function isMobileDevice() {
        if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
            || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) { 
            return true;
        }
        return false;
    }

    function isElectron() {
        if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') return true;
        if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) return true;
        if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) return true;
        return false;
    }

    function isChrome() {
        return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    }

    function aspectRatioFit(srcW, srcH, maxW, maxH) {
        const ratio = Math.min(maxW / srcW, maxH / srcH);
        return { width: srcW * ratio, height: srcH * ratio };
    }

    function randomRangeFloat(min, max) {
        return Math.random() * (max - min) + min;
    }

    function randomRangeInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function randomHexColor() {
        return "#000000".replace(/0/g, function() {
            return (~~(Math.random()*16)).toString(16).toUpperCase();
        });
    }

    function rgbIntToHex(r, g, b) {
        return '#' + (0x1000000 + b | (g << 8) | (r << 16)).toString(16).slice(1).toUpperCase();
    }

    function rgbFloatToHex(r, g, b) {
        const hr = Math.max(0, Math.min(255, Math.round(r * 255))).toString(16);
        const hg = Math.max(0, Math.min(255, Math.round(g * 255))).toString(16);
        const hb = Math.max(0, Math.min(255, Math.round(b * 255))).toString(16);
        return ("#" +
            (hr.length<2?"0":"") + hr +
            (hg.length<2?"0":"") + hg +
            (hb.length<2?"0":"") + hb).toUpperCase();
    }

    function hexToRgbFloat(hex, gammaCorrect = 1 / 0.5) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: Math.pow((parseInt(result[1], 16) / 255), gammaCorrect),
            g: Math.pow((parseInt(result[2], 16) / 255), gammaCorrect),
            b: Math.pow((parseInt(result[3], 16) / 255), gammaCorrect)
        } : null;
    }

    function getCanvasColor(context, x, y) {
        const data = context.getImageData(x, y, 1, 1).data;
        return rgbIntToHex(data[0], data[1], data[2]);
    }

    function parseBool(val) {
        return val === true || val === "true";
    }

    function parseINI(data){
        const regex = {
            section: /^\s*\[\s*([^\]]*)\s*\]\s*$/,
            param: /^\s*([^=]+?)\s*=\s*(.*?)\s*$/,
            comment: /^\s*;.*$/
        };
        const value = {};
        let lines = data.split(/[\r\n]+/);
        let section = null;
        lines.forEach(function(line) {
            if (regex.comment.test(line)) {
                return;
            } else if (regex.param.test(line)) {
                const match = line.match(regex.param);
                if (section) {
                    value[section][match[1]] = match[2];
                } else{
                    value[match[1]] = match[2];
                }
            } else if (regex.section.test(line)) {
                const match = line.match(regex.section);
                value[match[1]] = {};
                section = match[1];
            } else if (line.length == 0 && section) {
                section = null;
            }
        });
        lines = null;
        return value;
    }

    // source: https://doc.babylonjs.com/toolsAndResources/utilities/SurfaceMeshPoints
    function getRandomPointsOnMeshSurface(mesh, pointDensity) {
        let positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
        let indices = mesh.getIndices();
        let index = 0;
        let id0, id1, id2;
        let v0X, v0Y, v0Z;
        let v1X, v1Y, v1Z;
        let v2X, v2Y, v2Z;
        let vertex0 = BABYLON.Vector3.Zero();
        let vertex1 = BABYLON.Vector3.Zero();
        let vertex2 = BABYLON.Vector3.Zero();
        let vec0 = BABYLON.Vector3.Zero();
        let vec1 = BABYLON.Vector3.Zero();
        let vec2 = BABYLON.Vector3.Zero();
        let a, b, c, p;
        let area = 0;
        let nbPoints = 0;
        let lamda = 0;  
        let mu = 0;
        let facetPoint = null;
        let points = [];
        for (let index = 0; index < indices.length / 3; index++) {                
            id0 = indices[3 * index];
            id1 = indices[3 * index + 1]; 
            id2 = indices[3 * index + 2];        
            v0X = positions[3 * id0];
            v0Y = positions[3 * id0 + 1];
            v0Z = positions[3 * id0 + 2];
            v1X = positions[3 * id1];
            v1Y = positions[3 * id1 + 1];
            v1Z = positions[3 * id1 + 2];
            v2X = positions[3 * id2];
            v2Y = positions[3 * id2 + 1];
            v2Z = positions[3 * id2 + 2];
            vertex0.set(v0X, v0Y, v0Z);
            vertex1.set(v1X, v1Y, v1Z);
            vertex2.set(v2X, v2Y, v2Z);
            vertex1.subtractToRef(vertex0, vec0);
            vertex2.subtractToRef(vertex1, vec1);
            vertex2.subtractToRef(vertex0, vec2);
            a = vec0.length();
            b = vec1.length();
            c = vec2.length();
            p = (a + b + c) / 2;        
            area = Math.sqrt(p * (p - a) * (p - b) * (p - c));
            nbPoints = Math.round(pointDensity * area);
            for (let i = 0; i < nbPoints; i++) {
                lamda = BABYLON.Scalar.RandomRange(0, 1);   
                mu = BABYLON.Scalar.RandomRange(0, 1);
                // customizations for the voxel builder
                facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu)).floor();
                if (points.findIndex(i =>
                    i.x == facetPoint.x &&
                    i.y == facetPoint.y &&
                    i.z == facetPoint.z) == -1) {
                        points.push(facetPoint);
                    }
            }   
        }
        positions = null;
        indices = null;
        return points;
    }

    // source: https://gist.github.com/banksean/304522
    function ClassicalNoise() {
        this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], 
                     [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], 
                     [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]]; 
        this.p = [];
        for (let i = 0; i < 256; i++) {
            this.p[i] = Math.floor(Math.random()*256);
        }
        this.perm = [];
        for (let i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
        }
        this.dot = function(g, x, y, z) { 
            return g[0]*x + g[1]*y + g[2]*z; 
        }
        this.mix = function(a, b, t) { 
            return (1.0-t)*a + t*b; 
        }
        this.fade = function(t) { 
            return t*t*t*(t*(t*6.0-15.0)+10.0); 
        }
        this.noise = function(x, y, z) { // noise3D
            let X = Math.floor(x); 
            let Y = Math.floor(y); 
            let Z = Math.floor(z); 
            x = x - X; 
            y = y - Y; 
            z = z - Z; 
            X = X & 255; 
            Y = Y & 255; 
            Z = Z & 255;
            const gi000 = this.perm[X+this.perm[Y+this.perm[Z]]] % 12; 
            const gi001 = this.perm[X+this.perm[Y+this.perm[Z+1]]] % 12; 
            const gi010 = this.perm[X+this.perm[Y+1+this.perm[Z]]] % 12; 
            const gi011 = this.perm[X+this.perm[Y+1+this.perm[Z+1]]] % 12; 
            const gi100 = this.perm[X+1+this.perm[Y+this.perm[Z]]] % 12; 
            const gi101 = this.perm[X+1+this.perm[Y+this.perm[Z+1]]] % 12; 
            const gi110 = this.perm[X+1+this.perm[Y+1+this.perm[Z]]] % 12; 
            const gi111 = this.perm[X+1+this.perm[Y+1+this.perm[Z+1]]] % 12; 
            const n000= this.dot(this.grad3[gi000], x, y, z); 
            const n100= this.dot(this.grad3[gi100], x-1, y, z); 
            const n010= this.dot(this.grad3[gi010], x, y-1, z); 
            const n110= this.dot(this.grad3[gi110], x-1, y-1, z); 
            const n001= this.dot(this.grad3[gi001], x, y, z-1); 
            const n101= this.dot(this.grad3[gi101], x-1, y, z-1); 
            const n011= this.dot(this.grad3[gi011], x, y-1, z-1); 
            const n111= this.dot(this.grad3[gi111], x-1, y-1, z-1); 
            const u = this.fade(x); 
            const v = this.fade(y); 
            const w = this.fade(z); 
            const nx00 = this.mix(n000, n100, u); 
            const nx01 = this.mix(n001, n101, u); 
            const nx10 = this.mix(n010, n110, u); 
            const nx11 = this.mix(n011, n111, u); 
            const nxy0 = this.mix(nx00, nx10, v); 
            const nxy1 = this.mix(nx01, nx11, v); 
            return this.mix(nxy0, nxy1, w); // nxyz
        }
    }

    // source: https://playground.babylonjs.com/#2SA7J8#7
    const isTargetIn = (startPosition, endPosition, target, camera) => {
        const targetScreenPosition = BABYLON.Vector3.Project(
            target,
            BABYLON.Matrix.IdentityReadOnly,
            scene.getTransformMatrix(),
            camera.viewport.toGlobal(
                scene.getEngine().getRenderWidth(),
                scene.getEngine().getRenderHeight()
            )
        );
        if (targetScreenPosition.x >= Math.min(startPosition.x, endPosition.x) &&
            targetScreenPosition.x <= Math.max(startPosition.x, endPosition.x) &&
            targetScreenPosition.y >= Math.min(startPosition.y, endPosition.y) &&
            targetScreenPosition.y <= Math.max(startPosition.y, endPosition.y)) {
            return true;
        }
        return false;
    }

    // source: https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/VOXLoader.js
    function parseMagicaVoxel(buffer) {
        let data = new DataView(buffer);

        const id = data.getUint32(0, true);
        const version = data.getUint32(4, true);

        if (id !== 542658390 || version !== 150) {
            ui.notification( 'not a valid MagicaVoxel file');
            return;
        }

        let DEFAULT_PALETTE = [
            0x00000000, 0xffffffff, 0xffccffff, 0xff99ffff, 0xff66ffff, 0xff33ffff, 0xff00ffff, 0xffffccff,
            0xffccccff, 0xff99ccff, 0xff66ccff, 0xff33ccff, 0xff00ccff, 0xffff99ff, 0xffcc99ff, 0xff9999ff,
            0xff6699ff, 0xff3399ff, 0xff0099ff, 0xffff66ff, 0xffcc66ff, 0xff9966ff, 0xff6666ff, 0xff3366ff,
            0xff0066ff, 0xffff33ff, 0xffcc33ff, 0xff9933ff, 0xff6633ff, 0xff3333ff, 0xff0033ff, 0xffff00ff,
            0xffcc00ff, 0xff9900ff, 0xff6600ff, 0xff3300ff, 0xff0000ff, 0xffffffcc, 0xffccffcc, 0xff99ffcc,
            0xff66ffcc, 0xff33ffcc, 0xff00ffcc, 0xffffcccc, 0xffcccccc, 0xff99cccc, 0xff66cccc, 0xff33cccc,
            0xff00cccc, 0xffff99cc, 0xffcc99cc, 0xff9999cc, 0xff6699cc, 0xff3399cc, 0xff0099cc, 0xffff66cc,
            0xffcc66cc, 0xff9966cc, 0xff6666cc, 0xff3366cc, 0xff0066cc, 0xffff33cc, 0xffcc33cc, 0xff9933cc,
            0xff6633cc, 0xff3333cc, 0xff0033cc, 0xffff00cc, 0xffcc00cc, 0xff9900cc, 0xff6600cc, 0xff3300cc,
            0xff0000cc, 0xffffff99, 0xffccff99, 0xff99ff99, 0xff66ff99, 0xff33ff99, 0xff00ff99, 0xffffcc99,
            0xffcccc99, 0xff99cc99, 0xff66cc99, 0xff33cc99, 0xff00cc99, 0xffff9999, 0xffcc9999, 0xff999999,
            0xff669999, 0xff339999, 0xff009999, 0xffff6699, 0xffcc6699, 0xff996699, 0xff666699, 0xff336699,
            0xff006699, 0xffff3399, 0xffcc3399, 0xff993399, 0xff663399, 0xff333399, 0xff003399, 0xffff0099,
            0xffcc0099, 0xff990099, 0xff660099, 0xff330099, 0xff000099, 0xffffff66, 0xffccff66, 0xff99ff66,
            0xff66ff66, 0xff33ff66, 0xff00ff66, 0xffffcc66, 0xffcccc66, 0xff99cc66, 0xff66cc66, 0xff33cc66,
            0xff00cc66, 0xffff9966, 0xffcc9966, 0xff999966, 0xff669966, 0xff339966, 0xff009966, 0xffff6666,
            0xffcc6666, 0xff996666, 0xff666666, 0xff336666, 0xff006666, 0xffff3366, 0xffcc3366, 0xff993366,
            0xff663366, 0xff333366, 0xff003366, 0xffff0066, 0xffcc0066, 0xff990066, 0xff660066, 0xff330066,
            0xff000066, 0xffffff33, 0xffccff33, 0xff99ff33, 0xff66ff33, 0xff33ff33, 0xff00ff33, 0xffffcc33,
            0xffcccc33, 0xff99cc33, 0xff66cc33, 0xff33cc33, 0xff00cc33, 0xffff9933, 0xffcc9933, 0xff999933,
            0xff669933, 0xff339933, 0xff009933, 0xffff6633, 0xffcc6633, 0xff996633, 0xff666633, 0xff336633,
            0xff006633, 0xffff3333, 0xffcc3333, 0xff993333, 0xff663333, 0xff333333, 0xff003333, 0xffff0033,
            0xffcc0033, 0xff990033, 0xff660033, 0xff330033, 0xff000033, 0xffffff00, 0xffccff00, 0xff99ff00,
            0xff66ff00, 0xff33ff00, 0xff00ff00, 0xffffcc00, 0xffcccc00, 0xff99cc00, 0xff66cc00, 0xff33cc00,
            0xff00cc00, 0xffff9900, 0xffcc9900, 0xff999900, 0xff669900, 0xff339900, 0xff009900, 0xffff6600,
            0xffcc6600, 0xff996600, 0xff666600, 0xff336600, 0xff006600, 0xffff3300, 0xffcc3300, 0xff993300,
            0xff663300, 0xff333300, 0xff003300, 0xffff0000, 0xffcc0000, 0xff990000, 0xff660000, 0xff330000,
            0xff0000ee, 0xff0000dd, 0xff0000bb, 0xff0000aa, 0xff000088, 0xff000077, 0xff000055, 0xff000044,
            0xff000022, 0xff000011, 0xff00ee00, 0xff00dd00, 0xff00bb00, 0xff00aa00, 0xff008800, 0xff007700,
            0xff005500, 0xff004400, 0xff002200, 0xff001100, 0xffee0000, 0xffdd0000, 0xffbb0000, 0xffaa0000,
            0xff880000, 0xff770000, 0xff550000, 0xff440000, 0xff220000, 0xff110000, 0xffeeeeee, 0xffdddddd,
            0xffbbbbbb, 0xffaaaaaa, 0xff888888, 0xff777777, 0xff555555, 0xff444444, 0xff222222, 0xff111111];

        let i = 8;
        let chunk;
        const chunks = [];

        while (i < data.byteLength) {
            let id = '';
            for (let j = 0; j < 4; j++) {
                id += String.fromCharCode(data.getUint8(i++));
            }

            const chunkSize = data.getUint32(i, true);
            i += 4;
            i += 4; // childChunks

            if (id === 'SIZE') {
                const x = data.getUint32(i, true);
                i += 4;
                const y = data.getUint32(i, true);
                i += 4;
                const z = data.getUint32(i, true);
                i += 4;
                chunk = {
                    palette: DEFAULT_PALETTE,
                    size: { x: x, y: y, z: z }
                };
                chunks.push(chunk);
                i += chunkSize - (3 * 4);
            } else if (id === 'XYZI') {
                const numVoxels = data.getUint32(i, true);
                i += 4;
                chunk.data = new Uint8Array(buffer, i, numVoxels * 4);
                i += numVoxels * 4;
            } else if (id === 'RGBA') {
                const palette = [0];
                for (let j = 0; j < 256; j++) {
                    palette[j + 1] = data.getUint32(i, true);
                    i += 4;
                }
                chunk.palette = palette;
            } else {
                i += chunkSize;
            }
        }

        DEFAULT_PALETTE = null;
        data = null;
        buffer = null;
        return chunks;
    }


    // -------------------------------------------------------


    ui.domHelp.innerHTML = `
        <img width="100%" src="https://repository-images.githubusercontent.com/565157149/12cfcea1-6b9d-4d67-bea9-660ea9ad182b">
        <br><h1>Voxel-based 3D modeling application</h1>
        <br>A 3D modeling application for designers, artists and architects, to explore and develop ideas quickly, written in JavaScript and available for both desktop and mobile devices
        <br>
        <br><b>MODEL</b> - Create, draw and paint voxel particles
        <br><b>BAKE</b> - Bake voxels into mesh, transform, replicate and setup materials
        <br><b>RENDER</b> - Take screenshot, or export to GLB for more advanced use cases
        <br>
        <br><b>Supported Platforms</b>
        <br>- Electron
        <br>- Google Chrome for desktop
        <br>- Google Chrome for mobile devices (partially)
        <br><i>* tablet recommended for best experience</i>
        <br><i>* optimized for desktop and high-end mobile devices</i>
        <br>
        <br><h1>GENERAL</h1>
        <br>
        <br><b>File IO</b>
        <br>- Save and load project, custom VBX file, support both voxels and bakes
        <br>- Load from <a href="https://ephtracy.github.io/"><b>MagicaVoxel</b></a> <i>(voxel and color supported)</i>
        <br>- Export Voxels to GLB <i>(no grid texture, triangulated mess)</i>
        <br>- Export Bakes to GLB <i>(textures and materials included, support Blender)</i>
        <br>- Take pixel perfect screenshot to PNG <i>(support all three modes)</i>
        <br>- Import baked meshes from VBX file <i>(to import bakes from multiple files)</i>
        <br>- Support file drag and drop (VBX, VOX, OBJ, HDR, PNG/JPG/SVG)
        <br><i>* baked meshes stored as GLB in a VBX file</i>
        <br>
        <br><b>Local storage</b>
        <br>- Quick save and load support voxels and bakes <i>(topbar buttons)</i>
        <br><i>* remember to save both, they stored in different storages</i>
        <br>- Undo/redo supported by voxels, not bakes <i>(may change)</i>
        <br>- Data stored in the browser's history
        <br>- Memory support drawing, painting, symmetry, and respect hidden voxels
        <br>- Memory is cleared after loading a new model, or "clear cache"
        <br>
        <br><h1>MODEL</h1>
        <br>
        <br><b>Generator</b>
        <br>- Create grid, plane, sphere or oval
        <br>- Create isometric room
        <br>- Create random terrain
        <br><i>* generator resets scene, it is equal to a new project</i>
        <br><i>* use "box add" with optional "height" to draw walls</i>
        <br><i>* sphere/oval is not filled</i>
        <br>
        <br><b>3D Voxelization</b>
        <br>- Import OBJ from file, url and base64, merge and voxelize all meshes
        <br>- Increase "scale" amount for more details <i>(higher scale = more voxels)</i>
        <br>- Use "dense" to define the number of points per triangle faces <i>(density per area)</i>
        <br><i>* increase density to voxelize low-poly meshes</i>
        <br><i>* voxelized model is not filled</i>
        <br><i>* paste obj url: direct https links with ".obj" ending</i>
        <br>
        <br><b>2D Voxelization</b>
        <br>- Import JPG, PNG, SVG, and base64 image data
        <br>- Higher "ratio" for more details <i>(higher ratio = more voxels)</i>
        <br>- Use "pixel monk" to convert 2D shapes into 3D models
        <br><i>* do not "bake all colors", you don't want a mesh per pixel color!</i>
        <br><br><img src="https://github.com/nimadez/voxel-builder/raw/main/media/voxelization.jpg?raw=true">
        <br>
        <br><b>Symmetry</b>
        <br>- Symmetry supported by "add", "remove", "paint" and "pull" tools
        <br>- Symmetry supported by "box add", "box remove" and "box paint" tools
        <br>- Select [ X Y Z ] axis before start drawing and painting
        <br>- The pivot is the mesh center
        <br>- Symmetry respect hidden voxels
        <br>- Open "symm" menu to symmetrize or mirror/flip voxels
        <br>- Axis view contain a symmetry-axis indicator plane
        <br><br><img src="https://github.com/nimadez/voxel-builder/raw/main/media/symmetry.jpg?raw=true">
        <br>
        <br><b>Modeling</b>
        <br>- Free Camera: disable drawing and speed up navigation
        <br><i>* do not stay in drawing mode, switch to free camera after finish drawing</i>
        <br>- Add: add new voxels <i>(symmetry supported)</i>
        <br>- Remove: delete voxels <i>(symmetry supported)</i>
        <br>- Box Add: add voxels by drawing a box <i>(symmetry supported)</i>
        <br><i>* set "height" to larger than 0 (zero) to draw walls</i>
        <br><i>* draw line and connect two voxels at far distance as well</i>
        <br>- Box Remove: remove voxels by drawing a box <i>(symmetry supported)</i>
        <br>- Fill (slow): add a cluster of voxels to fill by rectangle area
        <br><i>* selection based on camera view, set camera angle carefully</i>
        <br><i>* use orthographic views to improve accuracy</i>
        <br><i>* use "workplane" to expand the selection area, make it easier to fill corners</i>
        <br>- Pull Voxel: pull a voxel <i>(symmetry supported)</i>
        <br>- Pull Color: pull voxels by color <i>(set a unique color to each part)</i>
        <br><i>* this tool overlap voxels in most cases, use "kill duplicates"</i>
        <br>- Workplane: draw anywhere in the space with a transformable workplane!
        <br><i>* support "add", "box add" and "fill" tools (include symmetry)</i>
        <br><i>* hit yellow gizmo to reset workplane on selected axis</i>
        <br><br><img src="https://github.com/nimadez/voxel-builder/raw/main/media/workplane.jpg?raw=true">
        <br>
        <br><b>Painting</b>
        <br>- Paint: paint color <i>(symmetry supported)</i>
        <br>- Box Paint: paint color by drawing a box <i>(symmetry supported)</i>
        <br>- Bucket: replace all similar colors
        <br>- Eyedropper: pick a voxel color, not a pixel color!
        <br>
        <br><b>Voxels</b>
        <br>- Onion Skin: display transparent voxels
        <br>- Normalize Voxel Positions: transform model to center and drop the base to the floor
        <br>- Reduce Voxels: remove all the voxels between the voxels <i>(1 voxel deleted in a 3x3x3 cube)</i>
        <br>- Kill Duplicates: remove all the duplicated voxels <i>(not supposed to happen by code)</i>
        <br>- Box Hide: hide voxels by drawing a box, hide single voxel as well
        <br>- Hide Color: hide voxels by picking voxels color
        <br>- Visibility options: use visibility options to access underlying voxels
        <br><i>* visibility is persistent, not break by drawing and painting</i>
        <br><i>* but you can't replace or delete hidden voxels</i>
        <br><i>* symmetry respect hidden voxels</i>
        <br><i>* bakery ignore hidden voxels</i>
        <br><i>* hidden voxels stored and restored on save/load and undo/redo</i>
        <br>
        <br><h1>BAKE</h1>
        <br>
        <br><b>Bake voxel particles into mesh</b>
        <br>- Updatable transformation, material and texture
        <br>- New Bake: add new bake <i>(bake a part)</i>
        <br>- Bake Color: bake by picking color <i>(bake a part)</i>
        <br>- Box Bake: bake by drawing a box <i>(bake a part)</i>
        <br><i>* mesh is not closed after cutting color groups</i>
        <br>- Bake All Colors: clear and bake all voxels grouped by colors <i>(bake multiple parts)</i>
        <br>- Per-Face UVs: define texture coordinates, custom 1:3 UVs, or per-face UVs
        <br><i>* unable to use the patterns and texture presets when checked</i>
        <br><br><img src="https://github.com/nimadez/voxel-builder/raw/main/media/bakery_faces.jpg?raw=true">
        <br>
        <br><b>Replicate and merge bakes</b>
        <br>- Clone: clone selected bake, not sharing material and texture
        <br>- Instance: instance selected bake, sharing material and texture
        <br><i>* they removed by deleting the source (unless reloading the file)</i>
        <br>- Merge Tool: click on pick button, select/deselect bakes, then hit merge!
        <br><i>* unable to merge instances, multi-material is not supported yet</i>
        <br>- Set Vertex Colors: set all vertex colors to albedo color
        <br>
        <br><b>Setup PBR material</b>
        <br>- Albedo, roughness, metallic, emissive and alpha properties
        <br>- Use replicate section to apply material/color to multiple bakes
        <br>- Use color pickers to update albedo color
        <br>
        <br><b>Import textures</b>
        <br>- Imported texture is not persistent, but attached to material and restored
        <br>- Custom UV Texture: PNG 8-bit 16x48 or larger <i>(1:3 ratio, bottom:bottom|sides:middle|top:top)</i>
        <br>- Per-Face UV Texture: All square images <i>(power of two)</i>
        <br><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTZCMzVFRUU4MzEwMTFFRDlBNzFFMTE4QzM2RUY4NUMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTZCMzVFRUQ4MzEwMTFFRDlBNzFFMTE4QzM2RUY4NUMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmE2MjNhNDkzLTgxYTMtZTY0NS1hNjkzLWIxMGJlN2ZkYTZiNyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6Pyqi/AAAAKlBMVEX54OL2+/1trUjx+Pz9/v/N6Pbd7/nY7fiKvHG31Kn///8bq+BiqDffACRQL3/wAAAAaklEQVR42syQSxKAMAhD8a+h3v+6dqgzYnRa3JkdrxBIZSdJDOCU7xDQyG9BJVwixYH9xwVWKxwoj24E5IHvYGPwsoXvSD1dWg2npCiwHYsHneqE8Q5yWwOU2ptCWx7KYH6YDmQaDXcIMADj0yJr4nQMSAAAAABJRU5ErkJggg==">
        <br>
        <br><h1>RENDER</h1>
        <br>
        <br>- Drone camera view
        <br>- Use HDR images to achieve realistic PBR rendering
        <br>- WASD controls on desktop, joystick controls on touchscreen
        <br>- Take pixel perfect screenshot to PNG <i>(render x3 larger, x2 on mobile)</i>
        <br>- Render mode render voxels if there is no bake to render
        <br><i>* flagged "preview", no PBR material and texture supported, render slower</i>
        <br><br><img src="https://github.com/nimadez/voxel-builder/raw/main/media/render.jpg?raw=true">
        <br>
        <br><h1>Axis View</h1>
        <br><b>Viewpoint</b>
        <br>- Tap on each axis to switch camera viewpoint for perspective and orthographic views
        <br><b>Frame camera</b>
        <br>- Tap the cube at center to frame camera
        <br><i>* model mode: frame all the voxels</i>
        <br><i>* bake mode: frame selected bake, or return to "model camera" if nothing selected</i>
        <br><i>* render mode: return to "bake camera" to render bakes, or return to "model camera" to render voxels</i>
        <br><i>* you can match all three cameras in turn (model > bake > render)</i>
        <br><b>Symmetry axis indicator</b>
        <br>- Axis view contain a symmetry-axis indicator plane
        <br><br><img src="https://github.com/nimadez/voxel-builder/raw/main/media/axisview.jpg?raw=true">
        <br>
        <br><h1>Hover Toolbox</h1>
        <br>- See "Toolbox"
        <br><i>* hover toolbox is draggable in "free camera" mode</i>
        <br><br><img src="https://github.com/nimadez/voxel-builder/raw/main/media/hover.jpg?raw=true">
        <br><i class="material-icons">control_camera</i> Free Camera
        <br><i class="material-icons">create</i> Add Voxels
        <br><i class="material-icons">clear</i> Remove Voxels
        <br><i class="material-icons">add</i> Box Add
        <br><i class="material-icons">remove</i> Box Remove
        <br><i class="material-icons">brush</i> Paint
        <br><i class="material-icons">imagesearch_roller</i> Box Paint
        <br><i class="material-icons">format_color_fill</i> Bucket
        <br><i class="material-icons">colorize</i> Eyedropper
        <br>
        <br><h1>Color Palette and Color Pickers</h1>
        <br>- Each color is a part (or group) in "model" mode
        <br>- Use color pickers in "bake" mode to multiply vertex colors to albedo color of the PBR material
        <br>- Combine colors and "visibility" options to create complex shapes
        <br>- Color palette generated dynamically as you draw, paint or delete voxels
        <br><i>* use double-click or double-tap on each color to toggle visibility</i>
        <br>
        <br><h1>Pixel Monk</h1>
        <br>- Integrated vector-based pixel editor
        <br>- Sketch out ideas or transform 2D into 3D
        <br>- Pixelate Images (JPG/PNG/SVG)
        <br>- Persistent memory (autosave), plus 3 storages
        <br>- Export PNG
        <br>- Support file drag and drop
        <br><i>* use base64 to paste image for 2D voxelization</i>
        <br><i>* use lower voxelizer "ratio" for better result</i>
        <br><br><img src="https://github.com/nimadez/voxel-builder/raw/main/media/pixelmonk.jpg?raw=true">
        <br>
        <br><h1>Asset Viewer</h1>
        <br>- Integrated model and hdri viewer
        <br>- Load OBJ, GLB, STL, FBX, HDR, EXR
        <br>- Export OBJ and GLB
        <br>- GLB and FBX animations
        <br>- PBR rendering and HDR lighting
        <br>- Support file drag and drop
        <br><i>* use base64 to paste model for 3D voxelization</i>
        <br><br><img src="https://github.com/nimadez/voxel-builder/raw/main/media/assetviewer.jpg?raw=true">
        <br>
        <br><h1>Statusbar Informations</h1>
        <br>FPS = measuring performance
        <br>VOX = total voxels
        <br>MSH = total baked meshes
        <br>VTX = total scene vertices <i>(include voxels)</i>
        <br>COL = total colors
        <br>FOV = camera field of view
        <br>FINAL/PREVIEW = current render mode
        <br>
        <br><h1>Keyboard Shortcuts</h1>
        <table><tbody>
            <tr><td>Space</td> <td>Free Camera</td></tr>
            <tr><td>A</td> <td>Add Tool</td></tr>
            <tr><td>B</td> <td>Box Add</td></tr>
            <tr><td>R</td> <td>Remove Tool</td></tr>
            <tr><td>T</td> <td>Transform Tool</td></tr>
            <tr><td>P</td> <td>Paint Tool</td></tr>
            <tr><td>B</td> <td>Bucket Tool</td></tr>
            <tr><td>E</td> <td>Eyedropper Tool</td></tr>
            <tr><td>S</td> <td>Switch Symmetry Axis</td></tr>
            <tr><td>W</td> <td>Toggle Workplane</td></tr>
            <tr><td>F</td> <td>Frame Camera</td></tr>
            <tr><td>O</td> <td>Debug Layer</td></tr>
            <tr><td>C</td> <td>Clone selected bake</td></tr>
            <tr><td>Delete</td> <td>Delete selected bake</td></tr>
            <tr><td>Ctrl+Z</td> <td>Undo</td></tr>
            <tr><td>Ctrl+X</td> <td>Redo</td></tr>
        </tbody></table>
        <br><table><tbody>
            <tr><td>W</td> <td>Move Forward</td></tr>
            <tr><td>A</td> <td>Move Left</td></tr>
            <tr><td>S</td> <td>Move Backward</td></tr>
            <tr><td>D</td> <td>Move Right</td></tr>
            <tr><td>E</td> <td>Move Upward</td></tr>
            <tr><td>Q</td> <td>Move Downward</td></tr>
            <tr><td>Shift</td> <td>Speed Up</td></tr>
        </tbody></table>
        <br>Check <a href="https://github.com/nimadez/voxel-builder/"><b>Repository</b></a> for more technical informations.
        <br>* English is not my first language, sorry for the typos!`;
</script>
</body>
</html>
